[{"title":"正则表达式","date":"2017-04-08T08:15:21.110Z","path":"2017/04/08/reg/","text":"正则表达式常用方法test用途：字符串判断 -返回真假 -正则.test(字符串) -例子：是否有不知数字的字符 123var str=\"akjkcs123232\";var re=/\\D/;alert(re.test(str));//true \\s : 空格\\S : 非空格\\d : 数字\\D : 非数字\\w : 字符 ( 字母 ，数字，下划线_ )\\W : 非字符*/ search用途：字符串搜索 -返回出现的位置 -字符串.search(正则) 12345678910111213141516//search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1//search的写法 : 字符串.search(正则)//正则中的默认 : 是区分大小写的 //如果不区分大小写的话，在正则的最后加标识 i var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i');alert( str.search(re) );//1 match用途：获取匹配项目 -返回数组 -量词+ -全局匹配g -例子：找出所有数字 123456789101112131415//match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null//match的写法 : 字符串.match(正则)//正则默认：正则匹配成功就会结束，不会继续匹配 //如果想全部查找，就要加标识 g(全局匹配)//量词 : 匹配不确定的位置//+ : 至少出现一次var str = 'haj123sdk54hask33dkhalsd879';var re = /\\d+/g;alert( str.match(re) ); //[123,54,33,879] replace用途：替换所有匹配 -返回替换后的字符串 -字符串.replace(正则) 12345678910//replace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串//replace的写法 : 字符串.replace(正则,新的字符串)var str = 'aaa';var re = /a+/g;str = str.replace(re,'b');alert(str);//b 下面给出一个敏感词过滤的例子 1234567891011121314151617181920212223242526272829303132333435//菲称仁爱礁附近17艘中国船均在菲军监视之下//| : 或的意思//replace : 第二个参数：可以是字符串，也可以是一个回调函数window.onload = function()&#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function()&#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re,function(str)&#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; 子项问题把正则的整体叫做（母亲）然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子)第二个小括号就是第二个孩子 1234567891011121314151617var str = '2013-6-7';var re = /(\\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0,$0.length-1) + '.'; &#125;);alert( str ); //2013.6.7 12345var str = 'abc';var re = /(a)(b)(c)/;alert( str.match(re) ); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) 字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符 12345var str = 'abdc';var re = /a[bde]c/;alert( re.test(str) );//false 排除排除 : ^ 如果^写在[]里面的话，就代表排除的意思 1234567891011var str = 'abc';var re = /a[^bde]c/;alert( re.test(str) );var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert( re.test(str) );//true . : 任意字符 , . : 真正的点12345var str = 'a.c';var re = /a\\.c/;alert(re.test(str));//true \\b : 独立的部分 （ 起始，结束，空格 ）, \\B : 非独立的部分12345var str = 'onetwo';var re = /o\\b/;alert( re.test(str) );//true 重复子项\\1 : 重复的第一个子项\\2 : 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\\2/;alert( re.test(str) );//false 量词 {4,7} : 最少出现4次，最多出现7次 {4,} : 最少出现4次 {4} : 正好出现4次 : {1,} //\\d{1,} ? : {0,1} : 出现0次或者1次 : {0,} : 至少出现0次 ^开始 $结束12//^ : 正则的最开始位置，就代笔起始的意思//$ : 正则的最后位置 , 就代笔结束的意思","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"刘美莲博客测试","date":"2017-04-08T08:13:28.199Z","path":"2017/04/08/test1/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"用对象下的属性替换字符串中的字符","date":"2017-04-08T02:35:32.848Z","path":"2017/04/08/replacestring/","text":"问题123456789var str='my name is $&#123;name.name&#125;,jian xie $&#123;b&#125;';var json=&#123; \"name\":&#123;\"name\":\"hzhuang\",\"minname\":\"zhuangzhuang\"&#125;, \"b\":\"hz\", \"n\":1, \"arr\":[1,2,3]&#125;;var result=str.render(json);console.log(result);//my name is hzhuang,jian xie hz 如上面的代码希望给str绑定一个函数render，是的result的结果是my name is hzhuang,jian xie hz 思路 用replace函数把str里的${name.name}，${b}替换成json里的数据 用json的数据替换str里的${name.name}，${b} 方法一123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(typeof obj[keys[i]]== 'object')&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析上述代码中（typeof obj[keys[i]]== ‘object’）的判断不够全面，因为typeof arr，其中arr为数组的话，弹出的也是object 方法二123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\")&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析Object.prototype.toString.call()是判断类型的一种方法,而且是能区分Array的方法 123456789101112String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; alert(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\"); //[object object],[object String],[object number],[object Array] &#125; return str;&#125; 方法三12345678910111213141516171819String.prototype.render = function (obj) &#123; var _this = this; for (var p in obj) &#123; if (obj.hasOwnProperty(p) &amp;&amp; !(p instanceof Object)) &#123; var s = '$&#123;' + p + '&#125;'; str = _this.replace(s, obj[p]); _this = str; &#125; if(obj[p] instanceof Object)&#123; for(var m in obj[p]) &#123; var x = '$&#123;' + p + '.' + m + '&#125;'; //console.log(obj[p][m]); str = _this.replace(x, obj[p][m]); _this = str; &#125; &#125; &#125; return str;&#125; ##解析 instanceof是区分的最细致的数据类型的函数 使用 instanceof 就是判断一个实例是否属于某种类型 123456789101112131415161718var oStringObject = new String(\"hello world\"); console.log(oStringObject instanceof String); // 输出 \"true\" // 判断 foo 是否是 Foo 类的实例 function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true typeof和instanceof的区别typeof和instanceof都可以用来判断变量，它们的用法有很大区别：typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；12345678910alert(typeof(1));//numberalert(typeof(\"abc\"));//stringalert(typeof(true));//booleanalert(typeof(m));//undefinedvar str=\"abc\";alert(typeof str);//stringvar arr=[];alert(typeof arr);//objectvar str1=new String(\"bjk\");alert(typeof str1);//object 可见区分不出str1和arr 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a) 若a未声明，则报错) 123if(typeof a != 'undefined')&#123; //变量存在&#125; 需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等，如： 123456var b = '123';alert(b instanceof String); //falsealert(typeof b); //stringvar c = new String(\"123\");alert(c instanceof String); //truealert(typeof c); //object 判断数组的几种方法 1、constructor属性 这个属性在我们使用js系统或者自己创建的对象的时候，会默认的加上，例如： arr = [1,2,3];link1234arr.prototype.constructor = Array; //这一句是系统默认加上的所以我们就可以这样来判断：var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 2、instanceofinstanceof是检测对象的原型链是否指向构造函数的prototype对象的，所以我们也可以用它来判断： 12var arr = [1,2,3]; alert(arr instanceof Array); // true 最后，为了给大家一个结果，现写出一个终极解决方案：判断数组终极解决方案arr = [1,2,3]; 12345678function isArrayFn(obj)&#123; //封装一个函数if (typeof Array.isArray === &quot;function&quot;) &#123; return Array.isArray(obj); //浏览器支持则使用isArray()方法&#125;else&#123; //否则使用toString方法return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;; &#125; &#125; alert(isArrayFn(arr));// true","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"字符串的操作","slug":"字符串的操作","permalink":"http://liumeilian.com.cn/tags/字符串的操作/"}]},{"title":"右边固定宽左边自适应的布局和左边固定宽度右边自适应的布局","date":"2017-04-07T13:50:25.437Z","path":"2017/04/07/a/","text":"右边固定宽左边自适应的布局这是一个简单的布局实现。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; margin-right: 200px; background-color:#ff0; height:500px; &#125; .right &#123; background-color:#f00; height:500px; width:200px; position: absolute; right: 0; top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 左边固定宽友边自适应的布局12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; width: 200px; background-color:#ff0; height:500px; float: left; &#125; .right &#123; background-color:#f00; height:500px; margin-left: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 注意当两个div元素同级时，就像main和aside，main来float与aside来float是不一样的。main来float那么这两个元素并列，如果aside来float那么这两个元素不在同一行，如果aside来float那么aside就会跑到main的下方。","tags":[{"name":"布局","slug":"布局","permalink":"http://liumeilian.com.cn/tags/布局/"}]},{"title":"刘美莲博客测试","date":"2017-04-04T13:40:13.757Z","path":"2017/04/04/text/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"查找两个字符串中最长的公共子串","date":"2017-03-25T12:48:33.000Z","path":"2017/03/25/maxLength/","text":"问题：str1=“aaa3333”；str2=“vscscsaaa33”;求str1和str2中最长的公共子串aaa33 思想：在长的字符串str2里面找最长的str1的子串 分析步骤： 1现在str2里面找 aaa3333，str1的长度是7，下标是0-6，先在str2中找str1的0-6的字符串aaa3333，找 的长度是7 2找不到aaa3333，再找str1中0-5的字符串aaa333，找不到，再找1-6的字符串aa3333，找不到，找的 长度是6。 3再找0-4的字符串aaa33，找到了就结束查找。 js代码实现：1234567891011121314151617181920 function LongestCommonStr(s1,s2)&#123; var str=\"\"; var L1=s1.length; var L2=s2.length; if(L1&gt;L2)&#123; L1=L2; var s3=s2; s2=s1; s1=s3; &#125; for(var j=L1;j&gt;0;j--)&#123; for(var i=0;i&lt;L1-j;i++)&#123; str=s1.substr(i,j); if(s2.indexOf(str)&gt;=0)&#123; return str; &#125; &#125; &#125; return \"\";&#125; 代码说明： 1外层的j循环代表先找7个，再找6个，再找5个str1中的子串 2内层循环代表先找0-4，再找1-5，再找2-6中的0 1 2这个顺序 2indexOf（searchvalue，fromindex）这个函数返回searchvalue出现的首位置，fromindex表示开始查到的位置，默认为0；","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]}]