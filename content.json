[{"title":"flex布局","date":"2017-04-12T07:39:59.710Z","path":"2017/04/12/flex/","text":"flex布局也就是弹性布局由于觉得阮一峰老师的博客已经写得非常详细，而且通俗易懂，这里附上他的链接，以后方便复习 Flex 布局教程：语法篇Flex 布局教程：实例篇 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 使用flex布局应该注意些什么 1.Webkit内核的浏览器，必须加上-webkit前缀。 2.任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。 3.设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 容器的属性以下6个属性设置在容器上。 1.flex-direction 2.flex-wrap 3.flex-flow 4.justify-content 5.align-items 6.align-content flex-direction属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse;} flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。.box{ flex-wrap: nowrap | wrap | wrap-reverse;} flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content属性justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch;} baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} stretch（默认值）：轴线占满整个交叉轴。 以下6个属性设置在项目上。 1.order 2.flex-grow 3.flex-shrink 4.flex-basis 5.flex 6.align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。","tags":[{"name":"css3","slug":"css3","permalink":"http://liumeilian.com.cn/tags/css3/"}]},{"title":"关于变量的作用域","date":"2017-04-11T13:50:58.577Z","path":"2017/04/11/funcaera/","text":"难以描述，直接上代码方便理解一些1234function a()&#123; alert(s);//这里会报错 s is not defined &#125; a(); 12345var c=s=10;//这里定义了一个全局变量s，且初始化为10function a()&#123; alert(s);//10&#125;a(); 12345var s=10; function a(s)&#123; alert(s);//10 &#125; a(s); 1234567var s=10; function a(s)&#123; var s;//由于s与形参名相同，所以相当于重新定义一边s，其实这个s就是形参s //虽然上面那句话没有初始化s，但是由于他就是形参s，所以里面的值还是10 alert(s);//10 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; alert(s);//20 &#125; a(s); 123456var s=10; function a(s)&#123; var s=20; alert(s);//20 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; &#125; a(s); alert(s);//10 123456function a()&#123; s=3; alert(s);//3 &#125; a(); alert(s);//3 12345var str=1;alert(str);//1str=\"adadwds\";alert(str);//adadwds，这里是不会报错的，//因为js的变量可以用来保存任何类型的值，虽然不推荐但是却没有错 解析好吧，感觉脑子快炸掉了 下面分析一下not define undefined null NaN一.not define1alert(a);//报错 a is not define not define说明变量没有被定义 undefined12var a;alert(a);//undefined undefined表示a已经被定义了，但是由于没有被初始化，所以系统给他赋值为undefined null12var a=document.getElementById(\"main\"); alert(a);//null null是Null类型的值，null值表示一个空对象的指针，一般用在一个变量想要保存一个对象但是还没有保存上面这个例子的意思就是a本来想保存一个对象，但是获取不到main所以他还是原来的值null NaN是Number类型的一个值意思是非数值NaN有两个特点，第一，任何涉及NaN的操作都会返回NaN，第二，NaN与任何值都不想等包括NaN本身isNaN函数接受一个参数，这个参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接受一个参数之后，会先尝试把这个参数转化成数值。某些不是数值的值会直接转化为数值，比如“10”或Boolean值。而任何不能被转化为数值的值都会导致这个函数返回true 12345alert(isNaN(NaN));//truealert(isNaN(10));//falsealert(isNaN(\"10\"));//falsealert(isNaN(\"blue\"));//truealert(isNaN(true));//false 这里再讨论一个题外话当没给setInterval设置时间函数的执行顺序是什么 12345setInterval(function()&#123; console.log(1); &#125;); console.log(2); 这个程序会先打印2，再打印1","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"原生jquery是如何写出来的","date":"2017-04-11T08:13:39.563Z","path":"2017/04/11/originjquery/","text":"原生jQ的写法$(function(){}) $(‘#div1’) $(‘.box’) $(‘p’)的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function $(vArg)&#123; return new Vquery(vArg);&#125;function Vquery(vArg)&#123; this.elements = []; //选择元素的这样一个集合 //vArg : function switch(typeof vArg)&#123; case 'function': //window.onload = vArg; bindEvent(window,'load',vArg); break; case 'string': switch( vArg.charAt(0) )&#123; case '#': //id this.elements.push(document.getElementById(vArg.substring(1))); break; case '.': //class this.elements = getByClass(document,vArg.substring(1)); break; default: //tag this.elements = toArray(document.getElementsByTagName(vArg)); break; &#125; break; case 'object': if( vArg.constructor == Array )&#123; this.elements = vArg; &#125; else&#123; this.elements.push( vArg ); &#125; break; &#125; &#125;function bindEvent(obj,events,fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(events,function(ev)&#123; //fn() -&gt; false //fn() -&gt; undefined if( fn() == false )&#123; ev.preventDefault(); ev.cancelBubble = true; &#125; &#125;,false); &#125; else&#123; obj.attachEvent('on'+events,function()&#123; if( fn() == false )&#123; window.event.cancelBubble = true; return false; &#125; &#125;); &#125;&#125;//下面是一些辅助函数function getByClass(oParent,sClass)&#123; var arr = []; var elems = oParent.getElementsByTagName('*'); for(var i=0;i&lt;elems.length;i++)&#123; if( elems[i].className == sClass )&#123; arr.push( elems[i] ); &#125; &#125; return arr; &#125;function toArray(elems)&#123; var arr = []; for(var i=0;i&lt;elems.length;i++)&#123; arr.push(elems[i]); &#125; return arr;&#125;function getStyle(obj,attr)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125; else&#123; return getComputedStyle(obj,false)[attr]; &#125;&#125; $().css() $().html()的实现12345678910111213141516171819202122Vquery.prototype.html = function(str)&#123; if(str)&#123; //设置 for(var i=0;i&lt;this.elements.length;i++)&#123; this.elements[i].innerHTML = str; &#125; &#125; else&#123; //获取 return this.elements[0].innerHTML; &#125; return this;&#125;;Vquery.prototype.click = function(fn)&#123; /*for(var i=0;i&lt;this.elements.length;i++)&#123; bindEvent(this.elements[i],'click',fn); &#125;*/ this.on('click',fn); return this; &#125;;","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"笔试中hotelnum","date":"2017-04-11T02:19:59.970Z","path":"2017/04/11/hotelnum/","text":"问题你要出去旅游，有N元的预算住酒店，有M家酒店供你挑选，这些酒店都有价格X。 需要你正好花完这N元住酒店（不能多，也不能少）最少能住几晚？返回最少住的天数，没有匹配的返回-1 比如你有1000元，所有酒店都是大于1000的，则返回-1 比如你有1000元，有1家1000元的，有1家300，有1家700。则最少能住1晚，最多住2晚（300+700）。返回1 比如你有1000元，有1家387元，有1家2元，有一家611，则返回3（3家各住1天） 比如你有1000元，有1家1元的，有一家2元的，有一家1001元的，则返回500（1元的1000天，2元的500天）输入n个int，最后一个int为你拥有的钱，[0, n-2]为酒店的价格 样例输入 1001 1002 1003 2001 1000 输出返回最少住的天数，没有匹配的返回-1 样例输出-1 思想 1.先把各个酒店的价格排序， 2.用剩下的钱除以剩下的酒店中价格最高的，这里如果商大于0，day要不断加加 3.用剩下的钱对剩下的酒店中价格最高的取余，如果余数为0，跳出循环 4.如果循环正常结束说明钱没有刚好花完，返回-1。 代码如下123456789101112131415161718192021222324252627282930313233343536var str1='1001 1002 1003 2001 1000'; var str2='300 700 1000 1000'; var str3='387 3 610 1000'; function hotelday(str)&#123; var arr=str.split(' '); for(var i=0;i&lt;arr.length;i++)&#123; arr[i]=parseInt(arr[i]); &#125; var money=arr[arr.length-1]; var hotel=[]; for(i=0;i&lt;arr.length-1;i++)&#123; hotel.push(arr[i]); &#125; hotel=hotel.sort(function compare(a,b)&#123; return a-b;//这里的compare是规定排序的方式 &#125;); var len=hotel.length; var day=0; for(i=len-1;i&gt;=0;i--)&#123; var shang=Math.floor(money/hotel[i]);//floor为向下取整,ceil为向上取整，round为四舍五入 var yushu=money%hotel[i]; if(shang!=0)&#123; day+=shang;//day记录天数 &#125; if(yushu==0)&#123; break;//余数为0就没有跳出循环 &#125; money=yushu; &#125; if(i==-1)&#123; return -1;//循环正常结束 &#125; return day; &#125; alert(hotelday(str3)); 区分sort和reverse 这两个函数功能不是相反的关系，这两个函数一点关系都没有 sort是把数组里的元素排列顺序 reverse是颠倒数组的元素的顺序,就是arr[0]和arr[length-1]交换,arr[1]和arr[length-2]交换 sort一盒带参数，reverse没有参数 sort 当sort没有参数时，数组是按照ASCII排列的，此时它把数组里的元素都看成是字符串，字符串排序首字母（a-z）或（1-9）这样的顺序 如果要对数组排序的话sort就一定要有参数 数字小到大compare(a,b){return a-b;} 数字大到小compare(a,b){return b-a;} 123456789101112131415 var arr=[12,23,53,13,15,5]; alert(arr.sort());//12 13 15 23 5 53 var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return a-b;&#125;alert(arr.sort(compare));//5 12 13 15 23 53var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return b-a;&#125;alert(arr.sort(compare));//53 23 15 13 12 5 reverse12var arr=[12,23,53,13,15,5];alert(arr.reverse());//5 15 14 53 23 12","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"函数的定义 函数声明 函数表达式 立即执行函数","date":"2017-04-08T12:28:16.653Z","path":"2017/04/08/function/","text":"函数的定义 1.函数通常是使用函数声明语法定义的，如下 123function sum(num1,num2)&#123; return num1+num2;&#125; 2.也可以用函数表达式定义,如下 123var sum=function(num1,num2)&#123; return num1+num2;&#125; 3.还可以用Function构造函数定义，如下 1var sum=new Function(\"num1\",\"num2\",\"return num1+num2\");//不推荐 函数声明与函数表达式的定义 函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。 函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 #函数声明与函数表达式的区别 一、JavaScript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式 二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 12345678910111213141516171819202122fnName();function fnName()&#123; ...&#125;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前fnName();var fnName=function()&#123; ...&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后var fnName=function()&#123; alert('Hello World');&#125;();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName()&#123; alert('Hello World');&#125;();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用function()&#123; console.log('Hello World'); &#125;();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名 在理解了一些函数基本概念后，回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法 1234567891011121314151617181920212223(function(a)&#123; console.log(a); //firebug输出123,使用（）运算符&#125;)(123);(function(a)&#123; console.log(a); //firebug输出1234，使用（）运算符&#125;(1234));!function(a)&#123; console.log(a); //firebug输出12345,使用！运算符&#125;(12345);+function(a)&#123; console.log(a); //firebug输出123456,使用+运算符&#125;(123456);-function(a)&#123; console.log(a); //firebug输出1234567,使用-运算符&#125;(1234567);var fn=function(a)&#123; console.log(a); //firebug输出12345678，使用=运算符&#125;(12345678) 可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"找出字符串中出现最多的字符和次数","date":"2017-04-08T11:53:17.281Z","path":"2017/04/08/maxstr/","text":"问题12var str = 'assssjdssskssalsssdkjsssdss';//找出str中出现最多的字符s 解答12345678910111213141516171819202122232425var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split('');str = arr.sort().join('');alert(str);//aadddjjkklsssssssssssssssssvar value = '';var index = 0;var re = /(\\w)\\1+/g;str.replace(re,function($0,$1)&#123; //alert($0); if(index&lt;$0.length)&#123; index = $0.length; value = $1; &#125; &#125;);alert('最多的字符:'+value+',重复的次数:'+index);","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"正则表达式","date":"2017-04-08T08:15:21.110Z","path":"2017/04/08/reg/","text":"正则表达式常用方法test用途：字符串判断 -返回真假 -正则.test(字符串) -例子：是否有不知数字的字符 123var str=\"akjkcs123232\";var re=/\\D/;alert(re.test(str));//true \\s : 空格\\S : 非空格\\d : 数字\\D : 非数字\\w : 字符 ( 字母 ，数字，下划线_ )\\W : 非字符*/ search用途：字符串搜索 -返回出现的位置 -字符串.search(正则) 12345678910111213141516//search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1//search的写法 : 字符串.search(正则)//正则中的默认 : 是区分大小写的 //如果不区分大小写的话，在正则的最后加标识 i var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i');alert( str.search(re) );//1 match用途：获取匹配项目 -返回数组 -量词+ -全局匹配g -例子：找出所有数字 123456789101112131415//match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null//match的写法 : 字符串.match(正则)//正则默认：正则匹配成功就会结束，不会继续匹配 //如果想全部查找，就要加标识 g(全局匹配)//量词 : 匹配不确定的位置//+ : 至少出现一次var str = 'haj123sdk54hask33dkhalsd879';var re = /\\d+/g;alert( str.match(re) ); //[123,54,33,879] replace用途：替换所有匹配 -返回替换后的字符串 -字符串.replace(正则) 12345678910//replace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串//replace的写法 : 字符串.replace(正则,新的字符串)var str = 'aaa';var re = /a+/g;str = str.replace(re,'b');alert(str);//b 下面给出一个敏感词过滤的例子 1234567891011121314151617181920212223242526272829303132333435//菲称仁爱礁附近17艘中国船均在菲军监视之下//| : 或的意思//replace : 第二个参数：可以是字符串，也可以是一个回调函数window.onload = function()&#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function()&#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re,function(str)&#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; 子项问题把正则的整体叫做（母亲）然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子)第二个小括号就是第二个孩子 1234567891011121314151617var str = '2013-6-7';var re = /(\\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0,$0.length-1) + '.'; &#125;);alert( str ); //2013.6.7 12345var str = 'abc';var re = /(a)(b)(c)/;alert( str.match(re) ); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) 字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符 12345var str = 'abdc';var re = /a[bde]c/;alert( re.test(str) );//false 排除排除 : ^ 如果^写在[]里面的话，就代表排除的意思 1234567891011var str = 'abc';var re = /a[^bde]c/;alert( re.test(str) );var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert( re.test(str) );//true . : 任意字符 , . : 真正的点12345var str = 'a.c';var re = /a\\.c/;alert(re.test(str));//true \\b : 独立的部分 （ 起始，结束，空格 ）, \\B : 非独立的部分12345var str = 'onetwo';var re = /o\\b/;alert( re.test(str) );//true 重复子项\\1 : 重复的第一个子项\\2 : 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\\2/;alert( re.test(str) );//false 量词 {4,7} : 最少出现4次，最多出现7次 {4,} : 最少出现4次 {4} : 正好出现4次 : {1,} //\\d{1,} ? : {0,1} : 出现0次或者1次 : {0,} : 至少出现0次 ^开始 $结束12//^ : 正则的最开始位置，就代笔起始的意思//$ : 正则的最后位置 , 就代笔结束的意思 用RegExp构造函数来创建正则表达式123var str=\"catastrophe\";var re=new RegExp(\"cat\",\"g\");re.test(str);//true 注意字符\\在字符串中通常被转义为\\,而在正则表达式中就会被转义为\\\\ 字面量模式和等价的字符串的比较如下 /[bc]at/ == “\\[bc\\]at” /.at/ ==”\\.at” /\\d.\\d{1,2}/ == “\\d.\\d{1,3}” /\\w\\hello\\123/ == “\\w\\\\hello\\\\123” 总之字面量的一个\\ 会变成两个\\ 1234567var str='R23C45';var re1=/^R\\d+C\\d+$/;var re2=new RegExp(\"^R\\d+C\\d+$\");var re3=new RegExp(\"^R\\\\d+C\\\\d+$\");alert(str.match(re1));//[R23C45]alert(str.match(re2));//nullalert(str.match(re3));//[R23C45]","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"用对象下的属性替换字符串中的字符","date":"2017-04-08T02:35:32.848Z","path":"2017/04/08/replacestring/","text":"问题123456789var str='my name is $&#123;name.name&#125;,jian xie $&#123;b&#125;';var json=&#123; \"name\":&#123;\"name\":\"hzhuang\",\"minname\":\"zhuangzhuang\"&#125;, \"b\":\"hz\", \"n\":1, \"arr\":[1,2,3]&#125;;var result=str.render(json);console.log(result);//my name is hzhuang,jian xie hz 如上面的代码希望给str绑定一个函数render，是的result的结果是my name is hzhuang,jian xie hz 思路 用replace函数把str里的${name.name}，${b}替换成json里的数据 用json的数据替换str里的${name.name}，${b} 方法一123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(typeof obj[keys[i]]== 'object')&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析上述代码中（typeof obj[keys[i]]== ‘object’）的判断不够全面，因为typeof arr，其中arr为数组的话，弹出的也是object 方法二123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\")&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析Object.prototype.toString.call()是判断类型的一种方法,而且是能区分Array的方法 123456789101112String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; alert(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\"); //[object object],[object String],[object number],[object Array] &#125; return str;&#125; 方法三12345678910111213141516171819String.prototype.render = function (obj) &#123; var _this = this; for (var p in obj) &#123; if (obj.hasOwnProperty(p) &amp;&amp; !(p instanceof Object)) &#123; var s = '$&#123;' + p + '&#125;'; str = _this.replace(s, obj[p]); _this = str; &#125; if(obj[p] instanceof Object)&#123; for(var m in obj[p]) &#123; var x = '$&#123;' + p + '.' + m + '&#125;'; //console.log(obj[p][m]); str = _this.replace(x, obj[p][m]); _this = str; &#125; &#125; &#125; return str;&#125; ##解析 instanceof是区分的最细致的数据类型的函数 使用 instanceof 就是判断一个实例是否属于某种类型 123456789101112131415161718var oStringObject = new String(\"hello world\"); console.log(oStringObject instanceof String); // 输出 \"true\" // 判断 foo 是否是 Foo 类的实例 function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true typeof和instanceof的区别typeof和instanceof都可以用来判断变量，它们的用法有很大区别：typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；12345678910alert(typeof(1));//numberalert(typeof(\"abc\"));//stringalert(typeof(true));//booleanalert(typeof(m));//undefinedvar str=\"abc\";alert(typeof str);//stringvar arr=[];alert(typeof arr);//objectvar str1=new String(\"bjk\");alert(typeof str1);//object 可见区分不出str1和arr 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a) 若a未声明，则报错) 123if(typeof a != 'undefined')&#123; //变量存在&#125; 需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等，如： 123456var b = '123';alert(b instanceof String); //falsealert(typeof b); //stringvar c = new String(\"123\");alert(c instanceof String); //truealert(typeof c); //object 判断数组的几种方法 1、constructor属性 这个属性在我们使用js系统或者自己创建的对象的时候，会默认的加上，例如： arr = [1,2,3];link1234arr.prototype.constructor = Array; //这一句是系统默认加上的所以我们就可以这样来判断：var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 2、instanceofinstanceof是检测对象的原型链是否指向构造函数的prototype对象的，所以我们也可以用它来判断： 12var arr = [1,2,3]; alert(arr instanceof Array); // true 最后，为了给大家一个结果，现写出一个终极解决方案：判断数组终极解决方案arr = [1,2,3]; 12345678function isArrayFn(obj)&#123; //封装一个函数if (typeof Array.isArray === &quot;function&quot;) &#123; return Array.isArray(obj); //浏览器支持则使用isArray()方法&#125;else&#123; //否则使用toString方法return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;; &#125; &#125; alert(isArrayFn(arr));// true","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"字符串的操作","slug":"字符串的操作","permalink":"http://liumeilian.com.cn/tags/字符串的操作/"}]},{"title":"右边固定宽左边自适应的布局和左边固定宽度右边自适应的布局","date":"2017-04-07T13:50:25.437Z","path":"2017/04/07/a/","text":"右边固定宽左边自适应的布局这是一个简单的布局实现。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; margin-right: 200px; background-color:#ff0; height:500px; &#125; .right &#123; background-color:#f00; height:500px; width:200px; position: absolute; right: 0; top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 左边固定宽友边自适应的布局12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; width: 200px; background-color:#ff0; height:500px; float: left; &#125; .right &#123; background-color:#f00; height:500px; margin-left: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 注意当两个div元素同级时，就像main和aside，main来float与aside来float是不一样的。main来float那么这两个元素并列，如果aside来float那么这两个元素不在同一行，如果aside来float那么aside就会跑到main的下方。","tags":[{"name":"布局","slug":"布局","permalink":"http://liumeilian.com.cn/tags/布局/"}]},{"title":"刘美莲博客测试","date":"2017-04-04T13:40:13.757Z","path":"2017/04/04/text/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"查找两个字符串中最长的公共子串","date":"2017-03-25T12:48:33.000Z","path":"2017/03/25/maxLength/","text":"问题：str1=“aaa3333”；str2=“vscscsaaa33”;求str1和str2中最长的公共子串aaa33 思想：在长的字符串str2里面找最长的str1的子串 分析步骤： 1现在str2里面找 aaa3333，str1的长度是7，下标是0-6，先在str2中找str1的0-6的字符串aaa3333，找 的长度是7 2找不到aaa3333，再找str1中0-5的字符串aaa333，找不到，再找1-6的字符串aa3333，找不到，找的 长度是6。 3再找0-4的字符串aaa33，找到了就结束查找。 js代码实现：1234567891011121314151617181920 function LongestCommonStr(s1,s2)&#123; var str=\"\"; var L1=s1.length; var L2=s2.length; if(L1&gt;L2)&#123; L1=L2; var s3=s2; s2=s1; s1=s3; &#125; for(var j=L1;j&gt;0;j--)&#123; for(var i=0;i&lt;L1-j;i++)&#123; str=s1.substr(i,j); if(s2.indexOf(str)&gt;=0)&#123; return str; &#125; &#125; &#125; return \"\";&#125; 代码说明： 1外层的j循环代表先找7个，再找6个，再找5个str1中的子串 2内层循环代表先找0-4，再找1-5，再找2-6中的0 1 2这个顺序 2indexOf（searchvalue，fromindex）这个函数返回searchvalue出现的首位置，fromindex表示开始查到的位置，默认为0；","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]}]