[{"title":"如何解决div里面img图片下方有空白的问题","date":"2017-04-14T12:40:24.288Z","path":"2017/04/14/img/","text":"一.问题：相信网站前端开发者可能会遇到这样的问题，&lt;div&gt;&lt;img src=&quot;picture.png&quot;/&gt;&lt;/div&gt; 这样的格式在html5的文档标准下会有一段空白区域，那么怎样去掉这部分空白区域呢？ 二.原因 首先我们要知道这部分空白产生的原因。图片默认的vertical-align是baseline， 也就是字母x的下边距，我们在图片后面写上x就是这样 可以看到图片是与字母x的下边距对齐的，也就是baseline，css2的文档中有这么一句解释，翻译过来也就是一个inline-block元素，如果里面没有inline元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线 三.解决方法 1.所以我们只需要将img图片display:block，即可去掉div和img之间的空白 2.或者将div的line-height设置得足够小，也可以去掉空白，例如div{line-height:5px;} 3.也可以将font-size设为0，实际上也是改变了line-height 4.当然，我们可以改变vertical-align，让它不是baseline，比如设置vertical-align:middle","tags":[{"name":"css","slug":"css","permalink":"http://liumeilian.com.cn/tags/css/"}]},{"title":"xxs和cors","date":"2017-04-13T14:10:04.579Z","path":"2017/04/13/XXS/","text":"一.xxs什么是xxsxxs叫跨域脚本攻击，它指的是攻击者往web页面里插入恶意html代码，当用户浏览该页面时，嵌入web里的html代码会被执行，从而达到恶意攻击用户的目的 为什么会产生xss原因是过滤不严 xss类型 反射式xss 这种xss，跨域代码一般会存在于某个链接中，当被攻击者访问这个链接时，跨域代码就没执行，这类跨域代码一般不会存储在服务器上 存储型XSS 跨域代码会存储在服务器上面的数据库中，所以可以进行持久攻击 基于DOM的xss这是由于客户端脚本自身的解析不正确导致的安全问题&lt;!–more&gt; 反射型Xss的攻击原理它通过给别人发送带有恶意脚本代码参数的URL，当URL地址呗打开，特有的恶意代码参数呗html解析，他的特点是非持久的用户点击链接才能引起比如： http://searchb.dangdang.com/?key=f&#39;,true,1);alert(1);// 常用测试方法：对整个输入（特别强调的是，整个HTTP请求都是输入，数据库取来的数据其实也是输入。HTTP请求包括GET、POST参数，COOKIE，URL，头部的REFERER等等）中每个地方都可以如下操作， 自己构造一个唯一的串，例如:myxsstestxxxx 将某个输入项（比如某个参数）替换为上面的串 查看HTTP相应中是否有这个串，并记录下来 根据HTML上下文决定，用哪种类型串来尝试，尝试攻击串，然后重新提交请求 如果能够找到相应的攻击串说明漏洞是存在的 这里的关键在于第四步，因为服务器端可能会做一些限制，比如encode或者长度限制，测试的时候需要想办法看看是否能绕过限制。 存储型XSS的攻击原理存储型就是攻击的脚本被存储到了数据库护着文件中，服务端（可能是别的应用或别的页面）在读取了存储的内容后回显了，这就是存储型这种情况用户打开页面就会看到 原理：xss代码被提交给网站-&gt;网站把xss代码存储进数据库-&gt;当页面再次被请求,服务端发送已经被植入XSS代码的数据给客户端-&gt;客户端执行XSS代码 DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞各种攻击的举例 ### dom-xss:1234567891011&lt;?phperror_reporting(0);$name = $_GET[\"name\"];?&gt;&lt;input id=\"text\" type=\"text\" value=\"&lt;?php echo $name;?&gt;\" /&gt;&lt;div id=\"print\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var text = document.getElementById(\"text\"); var print = document.getElementById(\"print\");print.innerHTML = text.value; // 获取 text的值，并且输出在print内。这里是导致xss的主要原因。&lt;/script&gt; 如下方式触发 存储型XXs123456789101112131415&lt;?phperror_reporting(0);$name = $_GET[\"name\"];//连接服务器$conn = mysql_connect(\"127.0.0.1\",\"root\",\"\");//打开数据库mysql_select_db(\"test\",$conn);//执行SQLmysql_query(\"set names 'utf8'\");$sql_insert = \"insert into liuyan(id,content) values('$id','$name')\";$result = mysql_query($sql_insert,$conn);$sql_select = \"select * from liuyan\";$results = mysql_fetch_array(mysql_query($sql_select));echo $results[content];?&gt; 先通过http://localhost/2.php?name=%3Cscript%3Ealert(1)%3C/script%3E然后再访问http://localhost/2.php。即可触发存储型xss： 反射型1234&lt;?php$name = $_GET[\"name\"];?&gt;&lt;input type=\"text\" value=\"&lt;?php echo $name?&gt;\"&gt; 结果： xxs的防范一句话：对输入做严格的过滤。对输出检查，转义，替换 二.csrf攻击概念：强迫受害者的浏览器向一个容易受攻击的web应用发送请求，达到攻击者的目的分类：站内和站外站内：由于程序员滥用$_REQUEST类变量造成，一些敏感的操作本来四要求要求用户从表单提交发起POST请求传参给程 序，但是由于使用了$_REQUEST等变量，程序也接收GET请求传参，这样就给攻击者使用CSRF攻击创造了条件，一般攻击者只要把预测好的请求参数 放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起请求站外：CSRF站外类型的漏洞其实就是传统意义上的外部提交数据问题，一般程序员会考虑给一些留言评论等的表单加上水印以防止SPAM问题，但是为了用户的体验 性，一些操作可能没有做任何限制，所以攻击者可以先预测好请求的参数，在站外的Web页面里编写javascript脚本伪造文件请求或和自动提交的表单 来实现GET、POST请求，用户在会话状态下点击链接访问站外的Web页面，客户端就被强迫发起请求","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"跨文档通信问题","date":"2017-04-13T02:26:13.700Z","path":"2017/04/13/cross/","text":"一.窗口跨域操作问题和postmessage的使用当父子页面在同一个域www.a.com下的时候，父子页面有包含关系，服页面通过iframe引入子页面这个时候可以用js在父页面中操作子页面的DoM元素，也可以在子页面中用js操作父页面 12345678910111213141516171819202122232425262728293031323334353637//www.a.com 下的1.iframe.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyIframe = document.getElementById('myframe'); oBtn.onclick = function() &#123; oMyIframe.contentWindow.document.body.style.background = 'red'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，改变2.iframe.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"2.iframe.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;//www.a.com下的2.iframe.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; parent.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这里是a.com下的2.iframe.html页面 &lt;input type=\"button\" value=\"点击我，改变1.iframe.html的背景色\" id=\"btn\" /&gt;&lt;/body&gt; 父页面操作子页面：如果我们要操作一个iframe里面的dom元素，首先要获取到iframe引入的页面的window,用contentWindow获取子页面操作父页面：window parent top都是window对象window : 当前窗口window对象parent : 父级窗口window对象top : 顶级窗口window对象 当一个页面通过通过window.open的方式打开另一个页面，且这两个页面在同一个域名www.a.com下的21234567891011121314151617181920212223242526272829303132333435363738//www.a.com下的3.window.open.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oBtn2 = document.getElementById('btn2'); var newWindow = null; oBtn.onclick = function() &#123; //window.open 返回被打开窗口的window对象 newWindow = window.open('4.window.open.html', '_blank'); &#125; oBtn2.onclick = function() &#123; newWindow.document.body.style.background = 'red'; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，开启一个新的窗口打开4.window.open.html页面\" id=\"btn\" /&gt; &lt;input type=\"button\" value=\"点击我，改变4.window.open.html页面的背景色\" id=\"btn2\" /&gt;&lt;/body&gt;//www.a.com下的4.window.open.htm&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //window.opener : 通过window.open方法打开当前页面的窗口window window.opener.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是a.com下的4.window.open.html页面 &lt;input type=\"button\" value=\"点击我，改变3.window.open.html页面的背景色\" id=\"btn\" /&gt;&lt;/body&gt; 可以通过window.open返回的window对象操作被打开的页面的Domwindow.opener : 通过window.open方法打开当前页面的窗口window可以通过window.opener操作打开当面页面的页面的Dom 当本页面和通过iframe包含的页面不在同一个域名下的时候，这样操作就会有跨域操作安全限制问题这是需要通过postmessage给另一个页面发送消息，当另一个页面接到某些消息让做一些操作 1234567891011121314151617181920212223242526272829303132//www.a.com下的6.postMessage.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyIframe = document.getElementById('myframe'); oBtn.onclick = function() &#123; oMyIframe.contentWindow.postMessage('1', 'http://www.b.com'); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，改变2.iframe.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"http://www.b.com/3.postMessage.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;//www.b.com下的3.postMessage.html&lt;script&gt;window.onload = function() &#123; window.addEventListener('message', function(ev) &#123; if (ev.data == '1') &#123; document.body.style.background = 'red'; &#125; &#125;, false);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是b.com的postMessage.html页面&lt;/body&gt; postMessage使用的方法是 ：接收消息的窗口的window对象.postMessage()，注意是接收接收消息的窗口哦，第一个参数：发送的数据第二个参数：接收数据的域名｛带上协议｝ message事件的事件对象ev保存了发送过来的信息，ev.data就是发送过来的数据 二.ajax请求跨域文件问题当ajax请求的是另一个域下的文件时，出现跨域问题在标准浏览器下，XMLHttpRequest对象已经是升级版本，支持了更多的特性，可以跨域了但是，如果想实现跨域请求，还需要后端的相关配合才可以后端如何配合，比如www.a.com下的7.ajax.html通过ajax请求www.b.com下的ajax.php文件那么ajax.php文件加一句header(‘Access-Control-Allow-Origin:http://www.a.com‘); //这是允许访问该资源的域 IE如果想实现跨域请求，则需要使用另外一个对象XDomainRequest去实现 123456789101112131415161718192021222324252627282930313233//www.a.com下的7.ajax&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //标准浏览器下的跨域解决 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125; &#125; xhr.open('get', 'http://localhost/miaov/HTML5-5/b/ajax.php', true); xhr.send(); //ie下的跨域解决 /* var oXDomainRequest = new XDomainRequest(); oXDomainRequest.onload = function() &#123; alert(this.responseText); &#125; oXDomainRequest.open('get', 'http://www.b.com/ajax.php', true); oXDomainRequest.send();*/ &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"获取跨域下内容\" id=\"btn\" /&gt;&lt;/body&gt; 三.解决跨域问题的jsonp方法跨域：跨域名 一个域名下的文件去请求了和他不一样的域名下的资源文件，那么就会产生跨域请求 JSONP : JSON with Padding 1.script标签 2.用script标签加载资源是没有跨域问题的 如何解决：在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数里面利用这个参数做一些事情然后需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当作这个函数的参数传入进去 举例：在客户端:在客户端用script请求，并且编写函数处理返回来的数据1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log(data);//test&#125;; 在服务端：把需要的数据用函数包裹起来1foo(\"test\"); 注意：基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求三.cors解决跨域问题cors详解 什么是CORSCORS（Cross-Origin Resource Sharing 跨源资源共享），当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 CORS的安全隐患跨域请求和Ajax技术都会极大地提高页面的体验，但同时也会带来安全的隐患，其中最主要的隐患来自于CSRF（Cross-site request forgery）跨站请求伪造 CORS验证机制出于安全原因，浏览器限制从脚本中发起的跨域HTTP请求。默认的安全限制为同源策略， 即JavaScript或Cookie只能访问同域下的内容。W3C推荐了一种跨域的访问验证的机制，即CORS（Cross-Origin Resource Sharing 跨源资源共享）。这种机制让Web应用服务器能支持跨站访问控制，使跨站数据传输更加安全，减轻跨域HTTP请求的风险。CORS验证机制需要客户端和服务端协同处理。 客户端处理机制基于上述的CSRF的风险，各主流的浏览器都会对动态的跨域请求进行特殊的验证处理。验证处理分为： 简单请求验证处理 预先请求验证处理。 简单请求当请求同时满足下面两个条件时，浏览器会直接发送GET请求，在同一个请求中做跨域权限的验证。 请求方法是下列之一： GET HEAD POST请求头中的Content-Type请求头的值是下列之一： application/x-www-form-urlencoded multipart/form-data text/plain 简单请求时，浏览器会直接发送跨域请求，并在请求头中携带Origin 的header，表明这是一个跨域的请求。服务器端接到请求后，会根据自己的跨域规则，通过Access-Control-Allow-Origin和Access-Control-Allow-Methods响应头，来返回验证结果。如果验证成功，则会直接返回访问的资源内容。如果验证失败，则返回403的状态码，不会返回跨域请求的资源内容。 预先请求当请求满足下面任意一个条件时，浏览器会先发送一个OPTION请求，用来与目标域名服务器协商决定是否可以发送实际的跨域请求。 请求方法不是下列之一： GET HEAD POST请求头中的Content-Type请求头的值不是下列之一： application/x-www-form-urlencoded multipart/form-data text/plain 浏览器在发现页面中有上述条件的动态跨域请求的时候，并不会立即执行对应的请求代码，而是会先发送Preflighted requests（预先验证请求），Preflighted requests是一个OPTION请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。 OPTIONS请求头部中会包含以下头部：Origin、Access-Control-Request-Method、Access-Control-Request-Headers。服务器收到OPTIONS请求后，设置Access-Control-Allow-Origin、Access-Control-Allow-Method、Access-Control-Allow-Headers头部与浏览器沟通来判断是否允许这个请求。如果Preflighted requests验证通过，浏览器才会发送真正的跨域请求。 如果Preflighted requests验证失败，则会返回403状态，浏览器不会发送真正的跨域请求。 服务端处理机制服务器端对于跨域请求的处理流程如下： 1.首先查看http头部有无origin字段； 2.如果没有，或者不允许，直接当成普通请求处理，结束； 3.如果有并且是允许的，那么再看是否是preflight(method=OPTIONS)； 4.如果不是preflight（简单请求），就返回Allow-Origin、Allow-Credentials等，并返回正常内容。 5.如果是preflight（预先请求），就返回Allow-Headers、Allow-Methods等，内容为空；","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"layout和css的hack详解","date":"2017-04-12T08:35:42.295Z","path":"2017/04/12/layout/","text":"一.layout概念看了网上对于layout的各种说法，这里用一句话来总结layout的概念，这个概念仅仅是便于自己的理解，并非官方定义layout：layout是元素的一个属性，有些元素本省具有layout属性，有的元素需要通过设置某些css才能获得layout属性 一个元素是否具有“layout”可能会引发如下的一些问题： IE 很多常见的浮动 bug 。 元素本身对一些基本属性的异常处理问题。 容器和其子孙之间的边距重叠(margin collapsing)问题。 使用列表时遇到的诸多问题。 背景图像的定位偏差问题。 使用脚本时遇到的浏览器之间处理不一致的问题。 下列元素应该是默认具有 layout 的：, , , , , , , , , , 下列 CSS 属性和取值将会让一个元素获得 layout： position: absolute绝对定位元素的包含区块(containing block)就会经常在这一方面出问题。 float: left|right由于 layout 元素的特性，浮动模型会有很多怪异的表现。 display: inline-block当一个内联级别的元素需要 layout 的时候往往就要用到它，这也可能也是这个 CSS 属性的唯一效果——让某个元素拥有 layout。“inline-block行为”在IE中是可以实现的，但是非常与众不同： IE/Win: inline-block and hasLayout 。 width: 除 “auto” 外的任意值很多人遇到 layout 相关问题发生时，一般都会先尝试用这个来修复。 height: 除 “auto” 外的任意值 height: 1% 就在 Holly Hack 中用到。 zoom: 除 “normal” 外的任意值 (MSDN) IE6中很多Bug特别是定位问题都可以通过触发layout得到解决，以上的解决方法无论是设置zoom:1还是设置width和height其实都是为了触发layout。二.css HackCSS hack 概念CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的简单地讲，css hack指各版本及各品牌浏览器之间对CSS解释后出现网页内容的误差(比如我们常说错位)的处理。由于各浏览器的内核不同，所以会造成一些误差就像JS一样，一个JS网页特效，在微软IE6、IE7、IE8浏览器有效果，但可能在火狐（Mozilla Firefox）谷歌浏览器无效，这样就叫做JS hack ，所以我们对于CSS来说他们来解决各浏览器对CSS解释不同所采取的区别不同浏览器制作不同的CSS样式的设置来解决这些问题就叫作CSS Hack。 比如：kwstu{width:300px;_width:200px;}，一般浏览器会先给元素使用width:300px;的样式，紧接着后面还有个_width:200px;由于下划线_width只有IE6可以识别，所以此样式在IE6中实际设置对象的宽度为200px，后面的把前面的给覆盖了，而其他浏览器不识别_width不会执行_width:200px;这句样式，所以在其他浏览器中设置对象的宽度就是300px; 各种css hack情况 1.大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持 (opera可识别除外)。 2.\\9 ：所有IE浏览器都支持 3._和- ：仅IE6支持 4.* ：IE6、E7支持 5.\\0 ：IE8、IE9支持，opera部分支持 6.\\9\\0 ：IE8部分支持、IE9支持 7.\\0\\9 ：IE8、IE9支持 兼容各大主流浏览器(最新版本)css hack汇总如下（最全的）：12345678910color:#000; /*w3c标准*/[;color:#f00;]; /*Webkit(chrome和safari)*/color:#666\\9; /*IE8*/*color:#999; /*IE7*/_color:#333; /*IE6*/&#125;:root .element&#123;color:#0f0\\9;&#125; /*IE9*/@media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0) &#123; .element&#123;color:#336699;&#125;&#125; /*opera*/@-moz-document url-prefix()&#123; .element&#123;color:#f1f1f1;&#125;&#125; /*Firefox*/ 上面写的顺序是不能改变的【说明】：“:root”伪类IE系列只有IE9支持，其他主流浏览器均支持，利用这一点来区分IE8和IE9。另外考虑到opera部分支持，完全支持:root,所以不使用。","tags":[{"name":"css","slug":"css","permalink":"http://liumeilian.com.cn/tags/css/"}]},{"title":"flex布局","date":"2017-04-12T07:39:59.710Z","path":"2017/04/12/flex/","text":"flex布局也就是弹性布局由于觉得阮一峰老师的博客已经写得非常详细，而且通俗易懂，这里附上他的链接，以后方便复习 Flex 布局教程：语法篇Flex 布局教程：实例篇 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 使用flex布局应该注意些什么 1.Webkit内核的浏览器，必须加上-webkit前缀。 2.任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。 3.设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 容器的属性以下6个属性设置在容器上。 1.flex-direction 2.flex-wrap 3.flex-flow 4.justify-content 5.align-items 6.align-content flex-direction属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse;} flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。.box{ flex-wrap: nowrap | wrap | wrap-reverse;} flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content属性justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch;} baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} stretch（默认值）：轴线占满整个交叉轴。 以下6个属性设置在项目上。 1.order 2.flex-grow 3.flex-shrink 4.flex-basis 5.flex 6.align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。","tags":[{"name":"css3","slug":"css3","permalink":"http://liumeilian.com.cn/tags/css3/"}]},{"title":"关于变量的作用域","date":"2017-04-11T13:50:58.577Z","path":"2017/04/11/funcaera/","text":"难以描述，直接上代码方便理解一些 1234function a()&#123; alert(s);//这里会报错 s is not defined &#125; a(); 12345var c=s=10;//这里定义了一个全局变量s，且初始化为10function a()&#123; alert(s);//10&#125;a(); 12345var s=10; function a(s)&#123; alert(s);//10 &#125; a(s); 1234567var s=10; function a(s)&#123; var s;//由于s与形参名相同，所以相当于重新定义一边s，其实这个s就是形参s //虽然上面那句话没有初始化s，但是由于他就是形参s，所以里面的值还是10 alert(s);//10 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; alert(s);//20 &#125; a(s); 123456var s=10; function a(s)&#123; var s=20; alert(s);//20 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; &#125; a(s); alert(s);//10 123456function a()&#123; s=3; alert(s);//3 &#125; a(); alert(s);//3 12345var str=1;alert(str);//1str=\"adadwds\";alert(str);//adadwds，这里是不会报错的，//因为js的变量可以用来保存任何类型的值，虽然不推荐但是却没有错 解析好吧，感觉脑子快炸掉了 下面分析一下not define undefined null NaN一.not define1alert(a);//报错 a is not define not define说明变量没有被定义 undefined12var a;alert(a);//undefined undefined表示a已经被定义了，但是由于没有被初始化，所以系统给他赋值为undefined null12var a=document.getElementById(\"main\"); alert(a);//null null是Null类型的值，null值表示一个空对象的指针，一般用在一个变量想要保存一个对象但是还没有保存上面这个例子的意思就是a本来想保存一个对象，但是获取不到main所以他还是原来的值null NaN是Number类型的一个值意思是非数值NaN有两个特点，第一，任何涉及NaN的操作都会返回NaN，第二，NaN与任何值都不想等包括NaN本身isNaN函数接受一个参数，这个参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接受一个参数之后，会先尝试把这个参数转化成数值。某些不是数值的值会直接转化为数值，比如“10”或Boolean值。而任何不能被转化为数值的值都会导致这个函数返回true 12345alert(isNaN(NaN));//truealert(isNaN(10));//falsealert(isNaN(\"10\"));//falsealert(isNaN(\"blue\"));//truealert(isNaN(true));//false 这里再讨论一个题外话当没给setInterval设置时间函数的执行顺序是什么 12345setInterval(function()&#123; console.log(1); &#125;); console.log(2); 这个程序会先打印2，再打印1","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"原生jquery是如何写出来的","date":"2017-04-11T08:13:39.563Z","path":"2017/04/11/originjquery/","text":"原生jQ的写法$(function(){}) $(‘#div1’) $(‘.box’) $(‘p’)的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function $(vArg)&#123; return new Vquery(vArg);&#125;function Vquery(vArg)&#123; this.elements = []; //选择元素的这样一个集合 //vArg : function switch(typeof vArg)&#123; case 'function': //window.onload = vArg; bindEvent(window,'load',vArg); break; case 'string': switch( vArg.charAt(0) )&#123; case '#': //id this.elements.push(document.getElementById(vArg.substring(1))); break; case '.': //class this.elements = getByClass(document,vArg.substring(1)); break; default: //tag this.elements = toArray(document.getElementsByTagName(vArg)); break; &#125; break; case 'object': if( vArg.constructor == Array )&#123; this.elements = vArg; &#125; else&#123; this.elements.push( vArg ); &#125; break; &#125; &#125;function bindEvent(obj,events,fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(events,function(ev)&#123; //fn() -&gt; false //fn() -&gt; undefined if( fn() == false )&#123; ev.preventDefault(); ev.cancelBubble = true; &#125; &#125;,false); &#125; else&#123; obj.attachEvent('on'+events,function()&#123; if( fn() == false )&#123; window.event.cancelBubble = true; return false; &#125; &#125;); &#125;&#125;//下面是一些辅助函数function getByClass(oParent,sClass)&#123; var arr = []; var elems = oParent.getElementsByTagName('*'); for(var i=0;i&lt;elems.length;i++)&#123; if( elems[i].className == sClass )&#123; arr.push( elems[i] ); &#125; &#125; return arr; &#125;function toArray(elems)&#123; var arr = []; for(var i=0;i&lt;elems.length;i++)&#123; arr.push(elems[i]); &#125; return arr;&#125;function getStyle(obj,attr)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125; else&#123; return getComputedStyle(obj,false)[attr]; &#125;&#125; $().css() $().html()的实现12345678910111213141516171819202122Vquery.prototype.html = function(str)&#123; if(str)&#123; //设置 for(var i=0;i&lt;this.elements.length;i++)&#123; this.elements[i].innerHTML = str; &#125; &#125; else&#123; //获取 return this.elements[0].innerHTML; &#125; return this;&#125;;Vquery.prototype.click = function(fn)&#123; /*for(var i=0;i&lt;this.elements.length;i++)&#123; bindEvent(this.elements[i],'click',fn); &#125;*/ this.on('click',fn); return this; &#125;;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"jq","slug":"jq","permalink":"http://liumeilian.com.cn/tags/jq/"}]},{"title":"笔试中hotelnum","date":"2017-04-11T02:19:59.970Z","path":"2017/04/11/hotelnum/","text":"问题你要出去旅游，有N元的预算住酒店，有M家酒店供你挑选，这些酒店都有价格X。 需要你正好花完这N元住酒店（不能多，也不能少）最少能住几晚？返回最少住的天数，没有匹配的返回-1 比如你有1000元，所有酒店都是大于1000的，则返回-1 比如你有1000元，有1家1000元的，有1家300，有1家700。则最少能住1晚，最多住2晚（300+700）。返回1 比如你有1000元，有1家387元，有1家2元，有一家611，则返回3（3家各住1天） 比如你有1000元，有1家1元的，有一家2元的，有一家1001元的，则返回500（1元的1000天，2元的500天）输入n个int，最后一个int为你拥有的钱，[0, n-2]为酒店的价格 样例输入 1001 1002 1003 2001 1000 输出返回最少住的天数，没有匹配的返回-1 样例输出-1 思想 1.先把各个酒店的价格排序， 2.用剩下的钱除以剩下的酒店中价格最高的，这里如果商大于0，day要不断加加 3.用剩下的钱对剩下的酒店中价格最高的取余，如果余数为0，跳出循环 4.如果循环正常结束说明钱没有刚好花完，返回-1。 代码如下123456789101112131415161718192021222324252627282930313233343536var str1='1001 1002 1003 2001 1000'; var str2='300 700 1000 1000'; var str3='387 3 610 1000'; function hotelday(str)&#123; var arr=str.split(' '); for(var i=0;i&lt;arr.length;i++)&#123; arr[i]=parseInt(arr[i]); &#125; var money=arr[arr.length-1]; var hotel=[]; for(i=0;i&lt;arr.length-1;i++)&#123; hotel.push(arr[i]); &#125; hotel=hotel.sort(function compare(a,b)&#123; return a-b;//这里的compare是规定排序的方式 &#125;); var len=hotel.length; var day=0; for(i=len-1;i&gt;=0;i--)&#123; var shang=Math.floor(money/hotel[i]);//floor为向下取整,ceil为向上取整，round为四舍五入 var yushu=money%hotel[i]; if(shang!=0)&#123; day+=shang;//day记录天数 &#125; if(yushu==0)&#123; break;//余数为0就没有跳出循环 &#125; money=yushu; &#125; if(i==-1)&#123; return -1;//循环正常结束 &#125; return day; &#125; alert(hotelday(str3)); 区分sort和reverse 这两个函数功能不是相反的关系，这两个函数一点关系都没有 sort是把数组里的元素排列顺序 reverse是颠倒数组的元素的顺序,就是arr[0]和arr[length-1]交换,arr[1]和arr[length-2]交换 sort一盒带参数，reverse没有参数 sort 当sort没有参数时，数组是按照ASCII排列的，此时它把数组里的元素都看成是字符串，字符串排序首字母（a-z）或（1-9）这样的顺序 如果要对数组排序的话sort就一定要有参数 数字小到大compare(a,b){return a-b;} 数字大到小compare(a,b){return b-a;} 123456789101112131415 var arr=[12,23,53,13,15,5]; alert(arr.sort());//12 13 15 23 5 53 var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return a-b;&#125;alert(arr.sort(compare));//5 12 13 15 23 53var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return b-a;&#125;alert(arr.sort(compare));//53 23 15 13 12 5 reverse12var arr=[12,23,53,13,15,5];alert(arr.reverse());//5 15 14 53 23 12","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"函数的定义 函数声明 函数表达式 立即执行函数","date":"2017-04-08T12:28:16.653Z","path":"2017/04/08/function/","text":"函数的定义 1.函数通常是使用函数声明语法定义的，如下 123function sum(num1,num2)&#123; return num1+num2;&#125; 2.也可以用函数表达式定义,如下 123var sum=function(num1,num2)&#123; return num1+num2;&#125; 3.还可以用Function构造函数定义，如下 1var sum=new Function(\"num1\",\"num2\",\"return num1+num2\");//不推荐 函数声明与函数表达式的定义 函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。 函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 #函数声明与函数表达式的区别 一、JavaScript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式 二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 12345678910111213141516171819202122fnName();function fnName()&#123; ...&#125;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前fnName();var fnName=function()&#123; ...&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后var fnName=function()&#123; alert('Hello World');&#125;();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName()&#123; alert('Hello World');&#125;();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用function()&#123; console.log('Hello World'); &#125;();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名 在理解了一些函数基本概念后，回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法 1234567891011121314151617181920212223(function(a)&#123; console.log(a); //firebug输出123,使用（）运算符&#125;)(123);(function(a)&#123; console.log(a); //firebug输出1234，使用（）运算符&#125;(1234));!function(a)&#123; console.log(a); //firebug输出12345,使用！运算符&#125;(12345);+function(a)&#123; console.log(a); //firebug输出123456,使用+运算符&#125;(123456);-function(a)&#123; console.log(a); //firebug输出1234567,使用-运算符&#125;(1234567);var fn=function(a)&#123; console.log(a); //firebug输出12345678，使用=运算符&#125;(12345678) 可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"找出字符串中出现最多的字符和次数","date":"2017-04-08T11:53:17.281Z","path":"2017/04/08/maxstr/","text":"问题12var str = 'assssjdssskssalsssdkjsssdss';//找出str中出现最多的字符s 解答12345678910111213141516171819202122232425var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split('');str = arr.sort().join('');alert(str);//aadddjjkklsssssssssssssssssvar value = '';var index = 0;var re = /(\\w)\\1+/g;str.replace(re,function($0,$1)&#123; //alert($0); if(index&lt;$0.length)&#123; index = $0.length; value = $1; &#125; &#125;);alert('最多的字符:'+value+',重复的次数:'+index);","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"正则表达式","date":"2017-04-08T08:15:21.110Z","path":"2017/04/08/reg/","text":"正则表达式常用方法test用途：字符串判断 -返回真假 -正则.test(字符串) -例子：是否有不知数字的字符 123var str=\"akjkcs123232\";var re=/\\D/;alert(re.test(str));//true \\s : 空格\\S : 非空格\\d : 数字\\D : 非数字\\w : 字符 ( 字母 ，数字，下划线_ )\\W : 非字符*/ search用途：字符串搜索 -返回出现的位置 -字符串.search(正则) 12345678910111213141516//search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1//search的写法 : 字符串.search(正则)//正则中的默认 : 是区分大小写的 //如果不区分大小写的话，在正则的最后加标识 i var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i');alert( str.search(re) );//1 match用途：获取匹配项目 -返回数组 -量词+ -全局匹配g -例子：找出所有数字 123456789101112131415//match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null//match的写法 : 字符串.match(正则)//正则默认：正则匹配成功就会结束，不会继续匹配 //如果想全部查找，就要加标识 g(全局匹配)//量词 : 匹配不确定的位置//+ : 至少出现一次var str = 'haj123sdk54hask33dkhalsd879';var re = /\\d+/g;alert( str.match(re) ); //[123,54,33,879] replace用途：替换所有匹配 -返回替换后的字符串 -字符串.replace(正则) 12345678910//replace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串//replace的写法 : 字符串.replace(正则,新的字符串)var str = 'aaa';var re = /a+/g;str = str.replace(re,'b');alert(str);//b 下面给出一个敏感词过滤的例子 1234567891011121314151617181920212223242526272829303132333435//菲称仁爱礁附近17艘中国船均在菲军监视之下//| : 或的意思//replace : 第二个参数：可以是字符串，也可以是一个回调函数window.onload = function()&#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function()&#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re,function(str)&#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; 子项问题把正则的整体叫做（母亲）然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子)第二个小括号就是第二个孩子 1234567891011121314151617var str = '2013-6-7';var re = /(\\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0,$0.length-1) + '.'; &#125;);alert( str ); //2013.6.7 12345var str = 'abc';var re = /(a)(b)(c)/;alert( str.match(re) ); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) 字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符 12345var str = 'abdc';var re = /a[bde]c/;alert( re.test(str) );//false 排除排除 : ^ 如果^写在[]里面的话，就代表排除的意思 1234567891011var str = 'abc';var re = /a[^bde]c/;alert( re.test(str) );var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert( re.test(str) );//true . : 任意字符 , . : 真正的点12345var str = 'a.c';var re = /a\\.c/;alert(re.test(str));//true \\b : 独立的部分 （ 起始，结束，空格 ）, \\B : 非独立的部分12345var str = 'onetwo';var re = /o\\b/;alert( re.test(str) );//true 重复子项\\1 : 重复的第一个子项\\2 : 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\\2/;alert( re.test(str) );//false 量词 {4,7} : 最少出现4次，最多出现7次 {4,} : 最少出现4次 {4} : 正好出现4次 : {1,} //\\d{1,} ? : {0,1} : 出现0次或者1次 : {0,} : 至少出现0次 ^开始 $结束12//^ : 正则的最开始位置，就代笔起始的意思//$ : 正则的最后位置 , 就代笔结束的意思 用RegExp构造函数来创建正则表达式123var str=\"catastrophe\";var re=new RegExp(\"cat\",\"g\");re.test(str);//true 注意字符\\在字符串中通常被转义为\\,而在正则表达式中就会被转义为\\\\ 字面量模式和等价的字符串的比较如下 /[bc]at/ == “\\[bc\\]at” /.at/ ==”\\.at” /\\d.\\d{1,2}/ == “\\d.\\d{1,3}” /\\w\\hello\\123/ == “\\w\\\\hello\\\\123” 总之字面量的一个\\ 会变成两个\\ 1234567var str='R23C45';var re1=/^R\\d+C\\d+$/;var re2=new RegExp(\"^R\\d+C\\d+$\");var re3=new RegExp(\"^R\\\\d+C\\\\d+$\");alert(str.match(re1));//[R23C45]alert(str.match(re2));//nullalert(str.match(re3));//[R23C45]","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"用对象下的属性替换字符串中的字符","date":"2017-04-08T02:35:32.848Z","path":"2017/04/08/replacestring/","text":"问题123456789var str='my name is $&#123;name.name&#125;,jian xie $&#123;b&#125;';var json=&#123; \"name\":&#123;\"name\":\"hzhuang\",\"minname\":\"zhuangzhuang\"&#125;, \"b\":\"hz\", \"n\":1, \"arr\":[1,2,3]&#125;;var result=str.render(json);console.log(result);//my name is hzhuang,jian xie hz 如上面的代码希望给str绑定一个函数render，是的result的结果是my name is hzhuang,jian xie hz 思路 用replace函数把str里的${name.name}，${b}替换成json里的数据 用json的数据替换str里的${name.name}，${b} 方法一123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(typeof obj[keys[i]]== 'object')&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析上述代码中（typeof obj[keys[i]]== ‘object’）的判断不够全面，因为typeof arr，其中arr为数组的话，弹出的也是object 方法二123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\")&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析Object.prototype.toString.call()是判断类型的一种方法,而且是能区分Array的方法 123456789101112String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; alert(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\"); //[object object],[object String],[object number],[object Array] &#125; return str;&#125; 方法三12345678910111213141516171819String.prototype.render = function (obj) &#123; var _this = this; for (var p in obj) &#123; if (obj.hasOwnProperty(p) &amp;&amp; !(p instanceof Object)) &#123; var s = '$&#123;' + p + '&#125;'; str = _this.replace(s, obj[p]); _this = str; &#125; if(obj[p] instanceof Object)&#123; for(var m in obj[p]) &#123; var x = '$&#123;' + p + '.' + m + '&#125;'; //console.log(obj[p][m]); str = _this.replace(x, obj[p][m]); _this = str; &#125; &#125; &#125; return str;&#125; ##解析 instanceof是区分的最细致的数据类型的函数 使用 instanceof 就是判断一个实例是否属于某种类型 123456789101112131415161718var oStringObject = new String(\"hello world\"); console.log(oStringObject instanceof String); // 输出 \"true\" // 判断 foo 是否是 Foo 类的实例 function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true typeof和instanceof的区别typeof和instanceof都可以用来判断变量，它们的用法有很大区别：typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；12345678910alert(typeof(1));//numberalert(typeof(\"abc\"));//stringalert(typeof(true));//booleanalert(typeof(m));//undefinedvar str=\"abc\";alert(typeof str);//stringvar arr=[];alert(typeof arr);//objectvar str1=new String(\"bjk\");alert(typeof str1);//object 可见区分不出str1和arr 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a) 若a未声明，则报错) 123if(typeof a != 'undefined')&#123; //变量存在&#125; 需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等，如： 123456var b = '123';alert(b instanceof String); //falsealert(typeof b); //stringvar c = new String(\"123\");alert(c instanceof String); //truealert(typeof c); //object 判断数组的几种方法 1、constructor属性 这个属性在我们使用js系统或者自己创建的对象的时候，会默认的加上，例如： arr = [1,2,3];link1234arr.prototype.constructor = Array; //这一句是系统默认加上的所以我们就可以这样来判断：var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 2、instanceofinstanceof是检测对象的原型链是否指向构造函数的prototype对象的，所以我们也可以用它来判断： 12var arr = [1,2,3]; alert(arr instanceof Array); // true 最后，为了给大家一个结果，现写出一个终极解决方案：判断数组终极解决方案arr = [1,2,3]; 12345678function isArrayFn(obj)&#123; //封装一个函数if (typeof Array.isArray === &quot;function&quot;) &#123; return Array.isArray(obj); //浏览器支持则使用isArray()方法&#125;else&#123; //否则使用toString方法return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;; &#125; &#125; alert(isArrayFn(arr));// true","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"字符串的操作","slug":"字符串的操作","permalink":"http://liumeilian.com.cn/tags/字符串的操作/"}]},{"title":"右边固定宽左边自适应的布局和左边固定宽度右边自适应的布局","date":"2017-04-07T13:50:25.437Z","path":"2017/04/07/a/","text":"右边固定宽左边自适应的布局这是一个简单的布局实现。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; margin-right: 200px; background-color:#ff0; height:500px; &#125; .right &#123; background-color:#f00; height:500px; width:200px; position: absolute; right: 0; top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 左边固定宽友边自适应的布局12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; width: 200px; background-color:#ff0; height:500px; float: left; &#125; .right &#123; background-color:#f00; height:500px; margin-left: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 注意当两个div元素同级时，就像main和aside，main来float与aside来float是不一样的。main来float那么这两个元素并列，如果aside来float那么这两个元素不在同一行，如果aside来float那么aside就会跑到main的下方。","tags":[{"name":"布局","slug":"布局","permalink":"http://liumeilian.com.cn/tags/布局/"}]},{"title":"刘美莲博客测试","date":"2017-04-04T13:40:13.757Z","path":"2017/04/04/text/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"查找两个字符串中最长的公共子串","date":"2017-03-25T12:48:33.000Z","path":"2017/03/25/maxLength/","text":"问题：str1=“aaa3333”；str2=“vscscsaaa33”;求str1和str2中最长的公共子串aaa33 思想：在长的字符串str2里面找最长的str1的子串 分析步骤： 1现在str2里面找 aaa3333，str1的长度是7，下标是0-6，先在str2中找str1的0-6的字符串aaa3333，找 的长度是7 2找不到aaa3333，再找str1中0-5的字符串aaa333，找不到，再找1-6的字符串aa3333，找不到，找的 长度是6。 3再找0-4的字符串aaa33，找到了就结束查找。 js代码实现：1234567891011121314151617181920 function LongestCommonStr(s1,s2)&#123; var str=\"\"; var L1=s1.length; var L2=s2.length; if(L1&gt;L2)&#123; L1=L2; var s3=s2; s2=s1; s1=s3; &#125; for(var j=L1;j&gt;0;j--)&#123; for(var i=0;i&lt;L1-j;i++)&#123; str=s1.substr(i,j); if(s2.indexOf(str)&gt;=0)&#123; return str; &#125; &#125; &#125; return \"\";&#125; 代码说明： 1外层的j循环代表先找7个，再找6个，再找5个str1中的子串 2内层循环代表先找0-4，再找1-5，再找2-6中的0 1 2这个顺序 2indexOf（searchvalue，fromindex）这个函数返回searchvalue出现的首位置，fromindex表示开始查到的位置，默认为0；","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]}]