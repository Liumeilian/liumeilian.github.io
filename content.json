[{"title":"用对象下的属性替换字符串中的字符","date":"2017-04-08T02:35:32.848Z","path":"2017/04/08/replacestring/","text":"问题123456789var str='my name is $&#123;name.name&#125;,jian xie $&#123;b&#125;';var json=&#123; \"name\":&#123;\"name\":\"hzhuang\",\"minname\":\"zhuangzhuang\"&#125;, \"b\":\"hz\", \"n\":1, \"arr\":[1,2,3]&#125;;var result=str.render(json);console.log(result);//my name is hzhuang,jian xie hz 如上面的代码希望给str绑定一个函数render，是的result的结果是my name is hzhuang,jian xie hz 思路 用replace函数把str里的${name.name}，${b}替换成json里的数据 用json的数据替换str里的${name.name}，${b} 方法一123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(typeof obj[keys[i]]== 'object')&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析上述代码中（typeof obj[keys[i]]== ‘object’）的判断不够全面，因为typeof arr，其中arr为数组的话，弹出的也是object 方法二123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\")&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析Object.prototype.toString.call()是判断类型的一种方法,而且是能区分Array的方法 123456789101112String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; alert(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\"); //[object object],[object String],[object number],[object Array] &#125; return str;&#125; 方法三12345678910111213141516171819String.prototype.render = function (obj) &#123; var _this = this; for (var p in obj) &#123; if (obj.hasOwnProperty(p) &amp;&amp; !(p instanceof Object)) &#123; var s = '$&#123;' + p + '&#125;'; str = _this.replace(s, obj[p]); _this = str; &#125; if(obj[p] instanceof Object)&#123; for(var m in obj[p]) &#123; var x = '$&#123;' + p + '.' + m + '&#125;'; //console.log(obj[p][m]); str = _this.replace(x, obj[p][m]); _this = str; &#125; &#125; &#125; return str;&#125; ##解析 instanceof是区分的最细致的数据类型的函数 使用 instanceof 就是判断一个实例是否属于某种类型 123456789101112131415161718var oStringObject = new String(\"hello world\"); console.log(oStringObject instanceof String); // 输出 \"true\" // 判断 foo 是否是 Foo 类的实例 function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true typeof和instanceof的区别typeof和instanceof都可以用来判断变量，它们的用法有很大区别：typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；12345678910alert(typeof(1));//numberalert(typeof(\"abc\"));//stringalert(typeof(true));//booleanalert(typeof(m));//undefinedvar str=\"abc\";alert(typeof str);//stringvar arr=[];alert(typeof arr);//objectvar str1=new String(\"bjk\");alert(typeof str1);//object 可见区分不出str1和arr 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a) 若a未声明，则报错) 123if(typeof a != 'undefined')&#123; //变量存在&#125; 需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等，如： 123456var b = '123';alert(b instanceof String); //falsealert(typeof b); //stringvar c = new String(\"123\");alert(c instanceof String); //truealert(typeof c); //object 判断数组的几种方法 1、constructor属性 这个属性在我们使用js系统或者自己创建的对象的时候，会默认的加上，例如： arr = [1,2,3];link1234arr.prototype.constructor = Array; //这一句是系统默认加上的所以我们就可以这样来判断：var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 2、instanceofinstanceof是检测对象的原型链是否指向构造函数的prototype对象的，所以我们也可以用它来判断： 12var arr = [1,2,3]; alert(arr instanceof Array); // true 最后，为了给大家一个结果，现写出一个终极解决方案：判断数组终极解决方案arr = [1,2,3]; 12345678function isArrayFn(obj)&#123; //封装一个函数if (typeof Array.isArray === &quot;function&quot;) &#123; return Array.isArray(obj); //浏览器支持则使用isArray()方法&#125;else&#123; //否则使用toString方法return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;; &#125; &#125; alert(isArrayFn(arr));// true","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"字符串的操作","slug":"字符串的操作","permalink":"http://liumeilian.com.cn/tags/字符串的操作/"}]},{"title":"右边固定宽左边自适应的布局和左边固定宽度右边自适应的布局","date":"2017-04-07T13:50:25.437Z","path":"2017/04/07/a/","text":"右边固定宽左边自适应的布局这是一个简单的布局实现。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; margin-right: 200px; background-color:#ff0; height:500px; &#125; .right &#123; background-color:#f00; height:500px; width:200px; position: absolute; right: 0; top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 左边固定宽友边自适应的布局12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; width: 200px; background-color:#ff0; height:500px; float: left; &#125; .right &#123; background-color:#f00; height:500px; margin-left: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 注意当两个div元素同级时，就像main和aside，main来float与aside来float是不一样的。main来float那么这两个元素并列，如果aside来float那么这两个元素不在同一行，如果aside来float那么aside就会跑到main的下方。","tags":[{"name":"布局","slug":"布局","permalink":"http://liumeilian.com.cn/tags/布局/"}]},{"title":"刘美莲博客测试","date":"2017-04-04T13:40:13.757Z","path":"2017/04/04/text/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"查找两个字符串中最长的公共子串","date":"2017-03-25T12:48:33.000Z","path":"2017/03/25/maxLength/","text":"问题：str1=“aaa3333”；str2=“vscscsaaa33”;求str1和str2中最长的公共子串aaa33 思想：在长的字符串str2里面找最长的str1的子串 分析步骤： 1现在str2里面找 aaa3333，str1的长度是7，下标是0-6，先在str2中找str1的0-6的字符串aaa3333，找 的长度是7 2找不到aaa3333，再找str1中0-5的字符串aaa333，找不到，再找1-6的字符串aa3333，找不到，找的 长度是6。 3再找0-4的字符串aaa33，找到了就结束查找。 js代码实现：1234567891011121314151617181920 function LongestCommonStr(s1,s2)&#123; var str=\"\"; var L1=s1.length; var L2=s2.length; if(L1&gt;L2)&#123; L1=L2; var s3=s2; s2=s1; s1=s3; &#125; for(var j=L1;j&gt;0;j--)&#123; for(var i=0;i&lt;L1-j;i++)&#123; str=s1.substr(i,j); if(s2.indexOf(str)&gt;=0)&#123; return str; &#125; &#125; &#125; return \"\";&#125; 代码说明： 1外层的j循环代表先找7个，再找6个，再找5个str1中的子串 2内层循环代表先找0-4，再找1-5，再找2-6中的0 1 2这个顺序 2indexOf（searchvalue，fromindex）这个函数返回searchvalue出现的首位置，fromindex表示开始查到的位置，默认为0；","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]}]