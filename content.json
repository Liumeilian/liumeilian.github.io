[{"title":"关于节流问题的debounce和Throttle","date":"2017-08-04T02:45:55.981Z","path":"2017/08/04/debounce/","text":"壮哥分享着东西还真是有用 大部分时候resize,scroll,mousemove和keydown/keyup/keypress发生的太平凡，我们不希望设这样的，所以希望节流 debounce概念：强制一个函数在某个连续时间段内只执行一次，我们希望在用户停止某个操作一段时间之后才执行相应的监听函数，而不是在用户操作过程中，浏览器触发多次事件，就执行多次监听函数 1234567891011121314151617181920212223242526272829/**** @param fn &#123;Function&#125; 实际要执行的函数* @param delay &#123;Number&#125; 延迟时间，也就是阈值，单位是毫秒（ms）** @return &#123;Function&#125; 返回一个“去弹跳”了的函数*/function debounce(fn, delay) &#123; // 定时器，用来 setTimeout var timer // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn clearTimeout(timer) // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作）， // 再过 delay 毫秒就执行 fn timer = setTimeout(function () &#123; fn.apply(context, args) &#125;, delay) &#125;&#125; debounce的使用方式如下：1234$(document).on('mouvemove', debounce(function(e) &#123; // 代码&#125;, 250))//用户触发很多mousemove操作结束之后250，才执行一次 Throttle概念：以固定的频率执行函数 throttle 的概念理解起来更容易，就是固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。比如在 1s 的时间段内，正常的监听函数可能会执行 50（1000/20） 次，“节流” 200ms 后则会执行 5（1000/200） 次。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**** @param fn &#123;Function&#125; 实际要执行的函数* @param delay &#123;Number&#125; 执行间隔，单位是毫秒（ms）** @return &#123;Function&#125; 返回一个“节流”函数*/function throttle(fn, threshhold) &#123; // 记录上次执行的时间 var last // 定时器 var timer // 默认间隔为 250ms threshhold || (threshhold = 250) // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数 return function () &#123; // 保存函数调用时的上下文和参数，传递给 fn var context = this var args = arguments var now = +new Date() // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃 // 执行 fn，并重新计时 if (last &amp;&amp; now &lt; last + threshhold) &#123; clearTimeout(timer) // 保证在当前时间区间结束后，再执行一次 fn timer = setTimeout(function () &#123; last = now fn.apply(context, args) &#125;, threshhold) // 在时间区间的最开始和到达指定间隔的时候执行一次 fn &#125; else &#123; last = now fn.apply(context, args) &#125; &#125;&#125; throttle 的使用方式如下： 123$(document).on('mouvemove', throttle(function(e) &#123; // 代码&#125;, 250)) 来这里体会一下","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"react小记2","date":"2017-07-20T09:03:05.757Z","path":"2017/07/20/react2/","text":"react中的this绑定this的三种方法 1.在constructor中绑定 this.handleClick=this.handleClick.bind(this); 2.在render里onClick={this.handleClick.bind(this)} 3.箭头函数 onClick={()=&gt;{this.handleClick()}}注意：为什么要绑定，因为需要函数里面的this指向该组件对象 key的作用key是用来唯一标识同父同层级的兄弟元素，key其实没有也行，但是会影响效率React在diff两棵树的时候，只要子元素有key属性，便会回去原来的v-dom树中找是否有相同key的元素，如果有相同key则比较是否完全相同，如果两个元素完全相同则复用，如果key同内容不同，则修改内容，若找不到相同的key则创建元素所以key的给定能提高效率 1234567891011121314//没有key//旧的v-dom&lt;ul&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;ul&gt;//新的v-dom&lt;ul&gt;&lt;li&gt;0&lt;/li&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;2&lt;/li&gt;&lt;ul&gt; 上面的情况react会比较新0与旧1，发现不等，把1改成0接着比较新1与旧2，发现不等，把2改成1，接着新2没有，创建一个2添加在后面 1234567891011121314//有key//旧的v-dom&lt;ul&gt;&lt;li key=\"1\"&gt;1&lt;/li&gt;&lt;li key=\"2\"&gt;2&lt;/li&gt;&lt;ul&gt;//新的v-dom&lt;ul&gt;&lt;li key=\"0\"&gt;0&lt;/li&gt;&lt;li key=\"1\"&gt;1&lt;/li&gt;&lt;li key=\"2\"&gt;2&lt;/li&gt;&lt;ul&gt; 有key的情况下，react此时只会创建key为0的元素，对原来的li进行了复用react中的key是决定销毁创建组件还是更新组件的 props和state的区别 props是用于父子组件通信的 state在组件内部维护自身状态 不要试图修改自身的props，除非你想自找麻烦 shouldComponentUpdatecomponentDidUpdate触发更新完成两个参数 1componentDidUpdate(preProps,prevState)&#123;&#125; react router2与react router4之间的差别下载：react-router-dom引入方式：import {BrowserRouter,Route,Link} from ‘react-router-dom’;Router标签写成BrowerRouterBrowserRouter下边只有一个子节点,用Switch作为BrowsweRouter的子节点不要history了Route 里做严格限制exact写在path前props的参数通过this.props.match获取 题外话：在webpack配置文件中写devServer:{historyApiFallback:true}能准确定位错误webpack-dev-server2之后后面不需要任何参数antd警告解决按需加载方法: npm install babel-plugin-import –save src下建一个文件.babelrc,写{“plugin”:[[“import”,{“libraryName”:”antd”}]]}或者这样解决：比如：import Button from ‘antd/lib/button’;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"react","slug":"react","permalink":"http://liumeilian.com.cn/tags/react/"}]},{"title":"作用域恶心两道题","date":"2017-07-19T14:36:07.522Z","path":"2017/07/19/erxingzuoyongyu/","text":"第一题123456789101112131415161718var n=10;var obj=&#123; n:20, fn:(function()&#123; this.n+=2; n*=3; return function()&#123; this.n*=2; n+=1; console.log(n); &#125; &#125;)(n)&#125;var fn=obj.fn;fn();obj.fn();console.log(n,obj.n); 函数从上到下执行的时候其实变成了这个样子 1234567891011var n=36;obj.n=20;obj.fn=function()&#123; this.n*=2; n+=1; console.log(n);&#125;var fn=obj.fn;fn();//this是window window.n=36*2+1=73obj.fn();//this是obj window.n=73+1=74 obj.n=20*2=40console.log(n,obj.n);//74 40 这样看是不是就一目了然了 从上到下执行自执行的时候自执行函数里面的this其实是window始终记住一句话this是函数运行时，谁调用这个函数，这个函数里面的this就是谁 第二题12345678910111213141516function Foo()&#123; getName=function()&#123;console.log(1);&#125; return this;&#125;Foo.getName=function()&#123;console.log(2);&#125;Foo.prototype.getName=function()&#123;console.log(3)&#125;var getName=function()&#123;console.log(4)&#125;function getName()&#123;console.log(5);&#125;Foo.getName();//2getName();//4Foo().getName();//1getName();//1new Foo.getName();//2 new Foo().getName();//3new new Foo().getName();//3","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"原生js写的轮播图","date":"2017-07-18T03:11:43.090Z","path":"2017/07/18/lunbotu/","text":"这看起来简单，原理也很简单，但是用原生写起来还是满费时间的 布局如下1234567891011121314151617181920212223242526272829303132333435363738//主要的css.img:nth-of-type(1)&#123; background: url('./0.jpg'); &#125; .img:nth-of-type(2)&#123; background: url('./1.jpg'); &#125; .img:nth-of-type(3)&#123; background: url('./2.jpg'); &#125; .img:nth-of-type(4)&#123; background: url('./3.jpg'); &#125; .img:nth-of-type(5)&#123; background: url('./0.jpg'); &#125; .img:nth-of-type(6)&#123; background: url('./1.jpg'); &#125; .img:nth-of-type(7)&#123; background: url('./2.jpg'); &#125; .img:nth-of-type(8)&#123; background: url('./3.jpg'); &#125; //主要的dom &lt;div class=\"contain\"&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt; &lt;div class=\"img\"&gt;&lt;/div&gt;&lt;/div&gt; 下面是主要的js1234567891011121314151617181920212223242526272829303132333435363738394041424344var nImg=getElementByClass(document,'img');//给元素设置定位nImg[0].style.left=0+'px';for(var i=1;i&lt;nImg.length;i++)&#123; nImg[i].style.left=300+'px'; &#125;var cur=0;var next=1;var timer2=setInterval(function()&#123; next=cur+1; if(next==8)&#123; next=0; &#125; moveTo(nImg[cur],0,-300); moveTo(nImg[next],300,0); cur=next;&#125;,3000);//获取一类元素的方法function getElementByClass(parent,className)&#123; var classobj=[]; var tags=parent.getElementsByTagName('*'); for(var i=0;i&lt;tags.length;i++)&#123; if(tags[i].nodeType==1)&#123; if(tags[i].className===className)&#123; classobj.push(tags[i]); &#125; &#125; &#125; return classobj;&#125;//移动到制定的地点function moveTo(elem,from,to)&#123; elem.style.left=from+'px'; var left_1=elem.offsetLeft; var timer=setInterval(function()&#123; left_1-=20; if(left_1&lt;=to)&#123; clearInterval(timer); &#125; elem.style.left=left_1+'px'; &#125;,100);&#125;&lt;/script&gt;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"阿里巴巴测评题-点击删除按钮删除父节点","date":"2017-07-17T02:54:49.189Z","path":"2017/07/17/alibababshi/","text":"题目贴出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!--code here--&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .head, li div &#123; display: inline-block; width: 70px; text-align: center; &#125; li .id, li .sex, .id, .sex &#123; width: 15px; &#125; li .name, .name &#123; width: 40px; &#125; li .tel, .tel &#123; width: 90px; &#125; li .del, .del &#123; width: 15px; &#125; ul &#123; list-style: none; &#125; .user-delete &#123; cursor: pointer; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"J_container\"&gt; &lt;div class=\"record-head\"&gt; &lt;div class=\"head id\"&gt;序号&lt;/div&gt;&lt;div class=\"head name\"&gt;姓名&lt;/div&gt;&lt;div class=\"head sex\"&gt;性别&lt;/div&gt;&lt;div class=\"head tel\"&gt;电话号码&lt;/div&gt;&lt;div class=\"head province\"&gt;省份&lt;/div&gt;&lt;div class=\"head\"&gt;操作&lt;/div&gt; &lt;/div&gt; &lt;ul id=\"J_List\"&gt; &lt;li&gt;&lt;div class=\"id\"&gt;1&lt;/div&gt;&lt;div class=\"name\"&gt;张三&lt;/div&gt;&lt;div class=\"sex\"&gt;男&lt;/div&gt;&lt;div class=\"tel\"&gt;13788888888&lt;/div&gt;&lt;div class=\"province\"&gt;浙江&lt;/div&gt;&lt;div class=\"user-delete\"&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=\"id\"&gt;2&lt;/div&gt;&lt;div class=\"name\"&gt;李四&lt;/div&gt;&lt;div class=\"sex\"&gt;女&lt;/div&gt;&lt;div class=\"tel\"&gt;13788887777&lt;/div&gt;&lt;div class=\"province\"&gt;四川&lt;/div&gt;&lt;div class=\"user-delete\"&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div class=\"id\"&gt;3&lt;/div&gt;&lt;div class=\"name\"&gt;王二&lt;/div&gt;&lt;div class=\"sex\"&gt;男&lt;/div&gt;&lt;div class=\"tel\"&gt;13788889999&lt;/div&gt;&lt;div class=\"province\"&gt;广东&lt;/div&gt;&lt;div class=\"user-delete\"&gt;删除&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt;// 此处也可换成ES6的写法function Contact()&#123; this.init();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 问题：点击删除操作删除一条li ###注意用面向对象的方法 解决方法一—-我的解决方法我最开始是想用面向对象的，但是平时都是在构造函数里面定义属性和方法，在原型上定义方法的，但是今天这个题在构造函数里面执行了这个函数，一下子让我觉得很懵逼浪费了我20分钟，导致我最后没有写完123456789101112131415161718192021222324252627Contact();function init()&#123; var nUserDeleteArr=getElementsByClass('user-delete'); var nUl=document.getElementById('J_List'); var nLiArr=document.getElementsByTagName('li'); for(var i=0;i&lt;nUserDeleteArr.length;i++)&#123; nUserDeleteArr[i].addEventListener('click',function()&#123; nUl.removeChild(this.parentNode); &#125;); &#125;&#125;//原生js获取一类元素的方法function getElementsByClass(classnames)&#123; var classobj = new Array(); var classint = 0; var tags =document.getElementsByTagName(\"*\"); for(var i in tags)&#123; if(tags[i].nodeType == 1)&#123; if(tags[i].getAttribute(\"class\") == classnames)&#123; classobj[classint] = tags[i]; classint++; &#125; &#125; &#125; return classobj; &#125; 我的方法有几个弊端： 1.没考虑兼容问题 2.没注释，谁看得懂 3.这个看不出面向对象 4.人家说最好用es6 5.最好做成事件委托 其实最开始的时候我是这样写的1234567function Contact()&#123; this.init();//这里居然报错我我百思不得其解,后来才知道原型上的方法必须先定义在使用，也就是new Contact（）要在init的定义之前&#125;var contact=new Contact();Contact.prototype.init=function()&#123; console.log('ok');&#125; 这个坑要永远记住 别人写的方法123456789101112131415161718192021222324252627282930313233343536373839function Contact()&#123; this.init();&#125;Contact.prototype.init=function()&#123; //一般浏览器 if(document.addEventListener)&#123; document.addEventListener('click',function(event)&#123; var e=event||window.event; var target=e.target||srcElement; if(target.className==='user-delete')&#123; var parent=target.parentNode; parent.parentNode.removeChild(parent); &#125; &#125;,false); &#125; //ie浏览器 else if(document.attachEvent)&#123; document.attachEvent('onclick',function(event)&#123; var e=event||window.event; var target=e.target||srcElement; if(target.className==='user-delete')&#123; var parent=target.parentNode; parent.parentNode.removeChild(parent); &#125; &#125;); &#125;else&#123; //自定义事件 document.onclick=function()&#123; var e=event||window.event; var target=e.target||srcElement; if(target.className==='user-delete')&#123; var parent=target.parentNode; parent.parentNode.removeChild(parent); &#125; &#125; &#125;&#125;var c=new Contact(); 这里的面向对象的方式是我写的，网友只提供了if里面的代码这里网友的写法有两个优点： 1.用了事件委托 2.考虑了兼容 ###鉴于此我总结一下我自认为这个题最好的方法本来想用这个的，但是不知道怎么给fn传参放弃了1234567function bindEvent(elem,event,fn)&#123; if(elem.addEventListener)&#123; elem.addEventListener(event,fn,false); &#125;else&#123; elem.attachEvent('on'+event,fn); &#125;&#125; 最终：下面是我认为较好的版本1234567891011121314151617181920212223242526272829function Contact()&#123; this.init();&#125;Contact.prototype.init=function()&#123; //兼容的函数绑定 function bindEvent(ele,event,fn) &#123; if(ele.addEventListener)&#123; ele.addEventListener(event,e=&gt; fn(e) ,false); &#125;else&#123; ele.attachEvent('on'+event,e=&gt; fn(e) ); &#125; &#125; //删除li function del(event)&#123; let e=event||window.event; let target=e.target||e.srcElement; if(target.classname==='user-delete')&#123; let parent=target.parentNode; parent.parentNode.removeChild(parent); &#125; &#125; bindEvent(document,'click',del);&#125;let contact=new Contact();//这里调用init 这里好歹用了点es6 这里考虑了兼容 有注释 面向对象 注意常用的操作dom的原生方法 createElement(); appendChild(); removeChild(); 常用的获取节点的方法 getElementsByTagName() getElementsById() 常用的父子节点 parentNode注意没有() childNodes注意没有()","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"git的常用命令以及多人协作开发流程","date":"2017-07-13T07:54:30.893Z","path":"2017/07/13/git/","text":"一.git开始一个项目 1.在git上创建一个项目 2.在本地创建一个项目test 3.在test目录下git init初始化仓库 4.在test目录下编写文件内容 5.git add .把文件添加到暂存区 6.git commit -m “XXX”,这个命令就是把暂存区里的文件都提交到本地仓库 7.git remote add origin XXX xxx代表远程仓库地址,这个命令就是给这个项目添加远程仓库地址 8.git push -u origin master,这个命令是把文件都提交到远程仓库origin的master分支,-u表示首次提交时如果没有origin master则创建，下次就不需要-u了 注意如果是git clone下来的项目则不需要git init也不需要git remote add originorigin是远程仓库的名称 二.其他常用命令 git status:查看状态 git pull是抓取远程仓库所有分支额更新合并到本地 git checkout -b XXX创建一个XXX分支 git checkout xxx切换到xxx分支 git branch查看有哪些分支 git clone是从无到有，git pull 是下载更新到本地合并三.多人合作开发一般多人合作开发需要配置SSH 配置密钥的步骤： 1.git config –list看看git里配置的username和email是谁的 2.如果git里的username和email不是你的，可以 git config –global user.name=”XXX” git config –global user.email “XXX” 3.查看是否已有ssh密钥 cd ~/.ssh 4.没有则生成密钥: ssh-keygen -t rsa -C “XXX” XXX是邮箱,按三个回车 cat ~/.ssh/id_rsa.pub此时就看到密钥 6.把这个密钥配置在git服务器上(在头像下的settings里的ssh里面) 7.配置完成之后级可以git clone了 四.多人开发的时候回出现一些常见的问题这里贴出一个链接多人开发教程","tags":[{"name":"git","slug":"git","permalink":"http://liumeilian.com.cn/tags/git/"}]},{"title":"简易版星级评分","date":"2017-06-20T09:26:53.894Z","path":"2017/06/20/starpingfen/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt; &lt;head&gt; &lt;title&gt;自定义对象级别插件&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"http://www.imooc.com/data/jquery-1.8.2.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; *&#123; margin: 0; padding:0; &#125; li&#123; list-style: none; width: 200px; background: url(\"./img/img.png\"); height: 200px; float: left; margin-left: 10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=\"light_ul_1\"&gt; &lt;li class=\"light_li\"&gt;&lt;/li&gt; &lt;li class=\"light_li\"&gt;&lt;/li&gt; &lt;li class=\"light_li\"&gt;&lt;/li&gt; &lt;li class=\"light_li\"&gt;&lt;/li&gt; &lt;li class=\"light_li\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script type=\"text/javascript\"&gt; $(function () &#123; var starOn=function(el)&#123; var starCount=0; lightOn( el,2); function lightOn(el,num)&#123; el.find('.light_li').each(function(index)&#123; if($(this).index() &lt; num)&#123; $(this).css('background-position','0 0'); &#125;else&#123; $(this).css('background-position','-200px 0'); &#125; &#125;); &#125; el.on('mouseover','.light_li',function()&#123; var num = $(this).index()+1; lightOn( $('.light_ul_1'),num); &#125;).on('click','.light_li',function()&#123; starCount=$(this).index()+1; console.log(starCount); &#125;).on('mouseout',function()&#123; lightOn( $('.light_ul_1'),starCount); &#125;); &#125; starOn($('.light_ul_1')); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"jQuery","slug":"jQuery","permalink":"http://liumeilian.com.cn/tags/jQuery/"}]},{"title":"放大镜","date":"2017-06-16T14:11:23.071Z","path":"2017/06/16/dangdajing/","text":"淘宝放大镜的写法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;放大镜&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0 &#125; body&#123; width: 2000px; &#125; #demo &#123; display: block; width: 400px; height: 255px; margin: 50px; position: relative; border: 1px solid #ccc; &#125; #small-box &#123; position: relative; z-index: 1; &#125; #float-box &#123; display: none; width: 160px; height: 120px; position: absolute; background: #ffffcc; border: 1px solid #ccc; filter: alpha(opacity=50); opacity: 0.5; &#125; #mark &#123; position: absolute; display: block; width: 400px; height: 255px; background-color: #fff; filter: alpha(opacity=0); opacity: 0; z-index: 10; &#125; #big-box &#123; display: none; position: absolute; top: 0; left: 460px; width: 400px; height: 300px; overflow: hidden; border: 1px solid #ccc; z-index: 1;; &#125; #big-box img &#123; position: absolute; &#125; &lt;/style&gt; &lt;script src=\"http://libs.baidu.com/jquery/1.10.0/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; //页面加载完毕后执行 window.onload = function () &#123; var objDemo = document.getElementById(\"demo\"); var objSmallBox = document.getElementById(\"small-box\"); var objMark = document.getElementById(\"mark\"); var objFloatBox = document.getElementById(\"float-box\"); var objBigBox = document.getElementById(\"big-box\"); var objBigBoxImage = objBigBox.getElementsByTagName(\"img\")[0]; objMark.onmouseover = function () &#123; objFloatBox.style.display = \"block\" objBigBox.style.display = \"block\" &#125; objMark.onmouseout = function () &#123; objFloatBox.style.display = \"none\" objBigBox.style.display = \"none\" &#125; console.log(objDemo.clientWidth); console.log($(objDemo).offset().left); objMark.onmousemove = function (ev) &#123; var _event = ev || window.event; //兼容多个浏览器的event参数模式 var left = _event.clientX - objDemo.offsetLeft - objSmallBox.offsetLeft - objFloatBox.offsetWidth / 2; var top = _event.clientY - objDemo.offsetTop - objSmallBox.offsetTop - objFloatBox.offsetHeight / 2; if (left &lt; 0) &#123; left = 0; &#125; else if (left &gt; (objMark.offsetWidth - objFloatBox.offsetWidth)) &#123; left = objMark.offsetWidth - objFloatBox.offsetWidth; &#125; if (top &lt; 0) &#123; top = 0; &#125; else if (top &gt; (objMark.offsetHeight - objFloatBox.offsetHeight)) &#123; top = objMark.offsetHeight - objFloatBox.offsetHeight; &#125; objFloatBox.style.left = left + \"px\"; //oSmall.offsetLeft的值是相对什么而言 objFloatBox.style.top = top + \"px\"; var percentX = left / (objMark.offsetWidth - objFloatBox.offsetWidth); var percentY = top / (objMark.offsetHeight - objFloatBox.offsetHeight); objBigBoxImage.style.left = -percentX * (objBigBoxImage.offsetWidth - objBigBox.offsetWidth) + \"px\"; objBigBoxImage.style.top = -percentY * (objBigBoxImage.offsetHeight - objBigBox.offsetHeight) + \"px\"; &#125; $('#mark').bind(\"mouseover\",function(ev)&#123; $('#float-box').show(); $('#big-box').show(); &#125;); $('#mark').bind(\"mouseout\",function(ev)&#123; $('#float-box').hide(); $('#big-box').hide(); &#125;); $('#mark').bind(\"mousemove\",function(ev)&#123; var ev=ev||window.event; var Left=ev.pageX-$('#mark').offset().left-$('#float-box').width()/2; var Top=ev.pageY-$('#mark').offset().top-$('#float-box').height()/2; if(Left&lt;0)&#123; Left=0; &#125;else if(Left&gt;$('#mark').width()-$('#float-box').width())&#123; Left=$('#mark').width()-$('#float-box').width(); &#125; if(Top&lt;0)&#123; Top=0; &#125;else if(Top&gt;$('#mark').height()-$('#float-box').height())&#123; Top=$('#mark').height()-$('#float-box').height(); &#125; var percent=$('#mark').width()/$('#float-box').width(); $('#float-box').css(&#123;\"left\":Left+\"px\",\"top\":Top+\"px\"&#125;); $('#big-box img').css(&#123;\"left\":-Left*percent+\"px\",\"top\":-Top*percent+\"px\"&#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"demo\"&gt; &lt;div id=\"small-box\"&gt; &lt;div id=\"mark\"&gt;&lt;/div&gt; &lt;div id=\"float-box\"&gt;&lt;/div&gt; &lt;img src=\"macbook-small.jpg\"/&gt; &lt;/div&gt; &lt;div id=\"big-box\"&gt; &lt;img src=\"macbook-big.jpg\"/&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"jquery","slug":"jquery","permalink":"http://liumeilian.com.cn/tags/jquery/"}]},{"title":"神奇数的个数","date":"2017-05-19T14:27:37.331Z","path":"2017/05/19/shengqishu/","text":"问题：神奇数：一个数的某两个数位组成的数是质数，那么这个数就是神奇数比如：153这个数13 31都是质数所以这个数153就是一个神奇数 求n 到 m之间的神奇数的个数 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var readline = require('readline');const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);rl.on('line', function(line) &#123; var tokens = line.split(' '); var a=tokens[0];//这个数n var b=tokens[1];//这个是m var count=0; for(var i=a;i&lt;=b;i++) &#123; var arr = i.toString().split(''); var flag=false; if (arr.length &gt;= 2) &#123; for (var j = 0; j &lt; arr.length; j++) &#123; for (k = 0; k &lt; arr.length; k++) &#123; if (j != k) &#123; var str1 = arr[j]; var str2 = arr[k]; var str=''; str+=arr[j]+arr[k]; var num = Number(str); if (iszhushu(num)) &#123; console.log(num); flag=true;//flag=true说明这个数是神奇数 break; &#125; &#125; &#125; if(flag==true)&#123; break; &#125; &#125; if(flag)&#123; count++; &#125; &#125; &#125; console.log(count);&#125;);function iszhushu(num) &#123;//判断是否为质数 var flag=true; for(var i=2;i&lt;num;i++)&#123; if(num%i==0)&#123; flag=false; &#125; &#125; return flag;&#125;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"顺时针输出矩阵","date":"2017-05-15T07:56:17.541Z","path":"2017/05/15/juzhengshunshizhengshuchu/","text":"1231 2 3 45 6 7 89 10 11 12 输出：1 2 3 4 8 12 11 10 9 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var str='3 4 1 2 3 4 5 6 7 8 9 10 11 12 '; var arr=str.split(' '); var arr3=[]; for(var i=2;i&lt;arr.length;i++)&#123; arr3.push(arr[i]); &#125; var m=arr[0]; var n=arr[1]; var arr1=[]; var l=0; var arr2=new Array(m); for(var j=0;j&lt;m;j++)&#123; var arr2=[]; for(var k=0;k&lt;n;k++)&#123; arr2.push(arr3[l++]); &#125; arr1.push(arr2); &#125; var out=[]; var roundsum=0; if(n&gt;=m)&#123; roundsum=parseInt((parseInt(m)+1)/2); &#125;else&#123; roundsum=parseInt((parseInt(n)+1)/2); &#125; console.log(roundsum); var startlie=0; var endlie=n; var starthang=0; var endhang=m; a(arr1); function a(arr)&#123; for(var round=0;round&lt;roundsum;round++)&#123; var arrlie=[]; for(var i=startlie;i&lt;endlie;i++)&#123; out.push(arr[round][i]); &#125; for(var j=starthang;j&lt;endhang;j++)&#123; arrlie.push(arr[j][n-1]); &#125; arrlie.shift(); arrlie.pop(); out.concat(arrlie); for(var i=endlie-1;i&gt;=startlie;i--)&#123; if(round==(m-1-round))&#123; break; &#125; out.push(arr[m-1-round][i]); &#125; arrlie=[]; for(var j=endhang-1;j&gt;=starthang;j--)&#123; if(round==(m-1-round))&#123; break; &#125; arrlie.push(arr[j][round]); &#125; arrlie.shift(); arrlie.pop(); if(arrlie)&#123; out.concat(arrlie); &#125; n--; startlie++; endlie--; starthang++; endhang--; &#125; console.log(out); &#125;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"css实现文本省略用...代替","date":"2017-05-13T13:12:45.405Z","path":"2017/05/13/textoverflow/","text":"方法一:适用于定宽高123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .a&#123;width:400px;height:300px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"a\"&gt;有一次他被她跟烦了，板着脸问：“赵默笙，你为什么老是跟着我？”她睁大眼睛：“以琛，是你笨还是我笨，哎，你那么聪明，一定是我笨了，我怎么这么失败，追了半天人家都不知道我在干什么！” 那时候他就老是要让她等。有一次她等久了朝他发脾气。“我都数到九百九十九了，你才来！下次要是让我数到一千我就再也不理你！”结果又一次，他被系里临时抓去开会，冗长的会议终于完了后他跑去，她居然还在这次她等得脾气都没了，只是委委屈屈地看着他说：“以琛，我都数了好几个九百九十九了。”而这七年来，他又多少次数九百九十九？不是没想过放弃，只是始终没办法数到一千。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; overflow:hidden:超出隐藏 white-space:nowrap:强制不换行 text-overflow:ellipsis:超出省略号代替方法二:适用于不定宽高,但有兼容性问题,多用在移动端; 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt;&lt;meta charset=\"UTF-8\"&gt; &lt;style&gt; .b &#123;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=\"b\"&gt;有一次他被她跟烦了，板着脸问：“赵默笙，你为什么老是跟着我？”她睁大眼睛：“以琛，是你笨还是我笨，哎，你那么聪明，一定是我笨了，我怎么这么失败，追了半天人家都不知道我在干什么！” 那时候他就老是要让她等。有一次她等久了朝他发脾气。“我都数到九百九十九了，你才来！下次要是让我数到一千我就再也不理你！”结果又一次，他被系里临时抓去开会，冗长的会议终于完了后他跑去，她居然还在这次她等得脾气都没了，只是委委屈屈地看着他说：“以琛，我都数了好几个九百九十九了。”而这七年来，他又多少次数九百九十九？不是没想过放弃，只是始终没办法数到一千。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; display:-webkit-box:box-flex布局 webkit-box-orient:vertical:垂直排列子元素-webkit-line-clamp:显示几行-overflow:hidden:超出隐藏","tags":[{"name":"css","slug":"css","permalink":"http://liumeilian.com.cn/tags/css/"}]},{"title":"最大公约数和互质数","date":"2017-04-28T12:12:33.568Z","path":"2017/04/28/gongyueshu/","text":"一.求两个数的最大公约数公约数就是两个数的最大公因子 123456789101112function maxnm(n,m)&#123; var z=0; while(1)&#123; z=n%m; if(z==0)&#123; break; &#125; n=m; m=z; &#125; return m; &#125; m就是最大公约数 二.看两个数是否互质两个整数的最大公约数为1，即可判断两个正整数互质 也就是 上面的返回的是1，那么n和m就是互质，返回大于1就不是互质 12345678function huzhi(l,k)&#123; var h=maxnm(l,k); if(h==1)&#123; return 1;//互质 &#125;else&#123; return 0;//不互质 &#125; &#125; 三.求小于n的与n互质的个数123456789function num(n)&#123; var count=0; for(var i=1;i&lt;n;i++)&#123; if(huzhi(i,n))&#123; count++; &#125; &#125; return count;&#125; count就是个数","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"seajs结合grunt是代码模块化","date":"2017-04-26T09:17:00.556Z","path":"2017/04/26/seajs/","text":"一.导入seajs库1.在官网上下载sea.jssea.js 2.写index.html文件，在index.html文件中src=\"sea.js\">```1233.加载入口模块，暂时定为main.js```seajs.use(&quot;/main.js&quot;); 还可以执行指定的回调1234//加载模块 main，并在加载完成时，执行指定回调seajs.use('./main', function(main) &#123; main.init();&#125;); 二.模块开发所有模块通过define来定义 1234567891011121314//main.jsdefine(function(require,exports,module)&#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick=function()&#123; oDiv1.style.display='block'; require('./scale.js').scale(oDiv1,oDiv2); &#125; &#125;); 通过require引入依赖,通过exports提供接口 上边的main.js模块依赖于drag.js和scale.js两个模块 12345678910111213141516//drag.jsdefine(function(require,exports,module)&#123; function drag(obj)&#123; L=require('range.js').range(L,document.documentElement.clientWidth-obj.offsetWidth,0); T=require('range.js').range(T,document.documentElement.clientHeight-obj.offsetHeight,0); &#125; exports.drag=drag;&#125;);//scale.jsdefine(function(requery,exports,module)&#123; function scale(obj1,obj2)&#123; &#125; exports.scale=scale;&#125;); drag.js模块依赖于rang.js模块 三.用grunt合并和压缩模块合并和压缩的方法在本博客中有grunt合并和压缩 grunt合在dist目录下的main.js中，此时需要在dist/main.js中做如下的修改123456789101112131415define('main.js',['./drag.js','./scale.js'],function(require,exports,module)&#123; &#125;);define('drag.js',['range.js'],function(require,exports,module)&#123; &#125;);define('scale.js',function(requery,exports,module)&#123; &#125;);// JavaScript Documentdefine('./range.js',function(require,exports,module)&#123; &#125;); 说明一下define(‘main.js’,[‘./drag.js’,’./scale.js’],function(require,exports,module){main.js是当前模块的名字，依赖模块是./drag.js和./scale.js 修改好了之后压缩代码为./dist/main.min.js 最后在index中修改seajs.use(‘./dist/main.min.js’);","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"grunt打包压缩的使用","date":"2017-04-26T03:40:54.315Z","path":"2017/04/26/grunt/","text":"参考网址 一.grunt的概念就是一个前端构建工具，比如打包代码，压缩代码等等 二.grunt如何实现打包压缩代码1.grunt和grunt所有的插件都是基于nodejs来运行的，首先要安装nodejs，很简单不多说，官网是https://nodejs.org/安装nodejs后，在控制台输入“node-v”来查看nodejs的版本 注意：grunt依赖于nodejs的v0.8.0以及以上的版本2.安装grunt-cli输入“npm install -g grunt-cli”如果安装成功，执行“grunt”会出现下面的结果 3.创建一个需要打包压缩的目录 1.创建一个需要打包压缩的目录sea，目录里有要打包和压缩的文件main.js,drag.js,scale.js,range.js等等 2.在sea目录下创建一个package.json文件，文件里面做如下写法： name就是我们给自己的项目取的名字，verson是给自己的项目取的版本devDependencies是开发依赖项的意思，也就是我们现在这个系统会依赖哪些工具来开发，现在先是空的，慢慢会填起来 4.安装grunt此时需要先进入项目的根目录sea，然后在这个目录下输入下面的命令“npm install grunt –save-dev” –save-dev的意思是在当前目录安装grunt的同时，顺便把grunt保存为这个目录的开发依赖项，此时会看到package.json文件中的“deDependencies”就有个grunt，如图：项目目录中还多个一个文件夹叫node_modules 5.配置Gruntfile.js如果说package。json是nodejs来用的，那么Gruntfile.js就是grunt来用的配置Gruntfile的方法如图：解释一下：这句话是在Gruntfile.js中获取package.json中的内容grunt有很多插件：Contrib-jshint——javascript语法错误检查；Contrib-watch——实时监控文件变化、调用相应的任务重新执行；Contrib-clean——清空文件、文件夹；Contrib-uglify——压缩javascript代码Contrib-copy——复制文件、文件夹Contrib-concat——合并多个文件的代码到一个文件中karma——前端自动化测试工具 这里我只说concat和uglify 先安装uglify和concat 执行npm install grunt-contrib-concat –save-dev和npm install grunt-contrib-uglify –save-dev 此时package.json文件中的deDependencies又增加了“grunt-contrib-concat”: “^1.0.1”, “grunt-contrib-uglify”: “^2.3.0” 在Gruntfile.js中这样写12345678910111213141516171819202122module.exports=function(grunt)&#123; grunt.initConfig(&#123; pkg:grunt.file.readJSON('package.json'), concat:&#123; sea:&#123; files:&#123; 'dist/main.js':['main.js','drag.js','scale.js','range.js'] &#125; &#125; &#125;, uglify:&#123; yasuo:&#123; files:&#123; 'dist/main.min.js':['dist/main.js'] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.registerTask('default',['concat','uglify']);&#125; 其中各个地方的意思如下 grunt.initConfig是任务配置，pkg表示获取package.json的内容，任务有concat和uglify两种任务在concat这种任务中有一个名称为sea的任务，这个sea名字随便取，files为sea这个任务下的文件配置files这个名称不能改，只能值files，其中dist/main.js表示后面的文件要合并到当前目录下的dist目录下的main.js中，后面是要合并的文件，合并的顺序就是后面文件的顺序grunt。loadNpmTasks表示我们将要使用的插件 registerTask表示告诉grunt当我们在控制台输入grunt时会发生什么. 执行grunt执行grunt就能在dist中看到合并和压缩的文件","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"事件委托的实现","date":"2017-04-24T15:23:54.838Z","path":"2017/04/24/delegate/","text":"#方法一：123456789101112131415&lt;ul class=\"ul-box\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;我是li-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;我是li-2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; (function () &#123; var ulNode = document.querySelector('.ul-box'); ulNode.addEventListener('click', handleClick, false); function handleClick(evt) &#123; evt.preventDefault(); var target = evt.target; alert(target.innerHTML); &#125; &#125;)()&lt;/script&gt;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"继承的几种方法","date":"2017-04-23T14:56:52.931Z","path":"2017/04/23/jicheng/","text":"一.组合继承思想：原型链实现对原型的属性和方法的继承，通过借用构造函数实现对实例属性的继承 1234567891011121314151617function SuperType(name)&#123; this.name=name; this.color=[\"red\",\"blue\"];&#125;SuperType.prototype.sayName=function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; SubType.call(this,name); this.age=age;&#125;SubType.prototype=new SuperType();SubType.prototype.constructor=SubType;SubType.prototype.sayAge=function()&#123; alert(this.age);&#125; 二.原型式继承思想：原型可以基于一个已有的对象创建对象，首先需要有一个对象作为另一个对象的基础 12345678910111213141516171819202122232425function object(o)&#123; function F()&#123;&#125; F.prototype=o; return new F();&#125;var person=&#123; namae:'nike', friends:[\"shek\",\"court\",\"van\"]&#125;var anotherPerson=object(person);anotherPerson.name=\"Grag\";anotherPerson.friends.push(\"Rob\");alert(person.friends);//[\"shek\",\"court\",\"van\",\"Rob\"]另一种：var anotherPerson=Object.create(person,&#123; name:&#123; value:'Greg' &#125;&#125;);alert(anotherPerson.name);//Greg 在没有必要新师动众的创建构造函数，而只想要一个对象与另一个对象保持类似时，原型继承可以胜任，但是包含引用类型值的属性始终都会共享 三.寄生式继承创建一个用于封装继承过程的函数，该函数在内部以某种方式来争强对象，最后返回这个对象 1234567function createAnother(original)&#123; var clone=object(original); clone.sayHi=function()&#123; alert('hi'); &#125; return clone;&#125; 这种不能做到函数复用，效率低","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"拖拽,磁性吸附，碰撞,模拟滚动条控制内容问题的封装","date":"2017-04-23T07:21:14.704Z","path":"2017/04/23/drag/","text":"一.拖拽先来普及一下全局捕获aInput[0].setCapture(); //设置全局捕获 ，当我们给一个元素设置全局捕获以后，那么这个元素就会监听后续发生的所有事件，当有事件发生的时候，就会被当前设置了全局捕获的元素所触发 ie : 有，并且有效果 ff : 有，但是没效果 chrome : 没有 1.拖拽的时候，如果有文字被选中，会产生问题 原因：当鼠标按下的时候，如果页面中有文字被选中，那么会触发浏览器默认拖拽文字的效果 解决： 标准：阻止默认行为 非标准ie：全局捕获 拖拽图片会有问题，原因，解决的办法同上12345678910111213141516171819202122232425262728293031323334353637383940414243window.onload = function() &#123; var oDiv = document.getElementById('div1'); var oImg = document.getElementById('img1'); drag(oImg); drag(oDiv); function drag(obj) &#123; obj.onmousedown = function(ev) &#123; var ev = ev || event; var disX = ev.clientX - this.offsetLeft; var disY = ev.clientY - this.offsetTop; if ( obj.setCapture ) &#123; obj.setCapture(); &#125; document.onmousemove = function(ev) &#123; var ev = ev || event; obj.style.left = ev.clientX - disX + 'px'; obj.style.top = ev.clientY - disY + 'px'; &#125; document.onmouseup = function() &#123; document.onmousemove = document.onmouseup = null; //释放全局捕获 releaseCapture(); if ( obj.releaseCapture ) &#123; obj.releaseCapture(); &#125; &#125; return false; &#125; &#125; &#125; 二.磁性吸附123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566window.onload = function() &#123; var oDiv = document.getElementById('div1'); var oImg = document.getElementById('img1'); drag(oImg); drag(oDiv); function drag(obj) &#123; obj.onmousedown = function(ev) &#123; var ev = ev || event; var disX = ev.clientX - this.offsetLeft; var disY = ev.clientY - this.offsetTop; if ( obj.setCapture ) &#123; obj.setCapture(); &#125; document.onmousemove = function(ev) &#123; var ev = ev || event; var L = ev.clientX - disX; var T = ev.clientY - disY; if ( L &lt; 100 ) &#123; L = 0; &#125; else if ( L &gt; document.documentElement.clientWidth - obj.offsetWidth ) &#123; L = document.documentElement.clientWidth - obj.offsetWidth; &#125; if ( T &lt; 0 ) &#123; T = 0; &#125; else if ( T &gt; document.documentElement.clientHeight - obj.offsetHeight ) &#123; T = document.documentElement.clientHeight - obj.offsetHeight; &#125; obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125; document.onmouseup = function() &#123; document.onmousemove = document.onmouseup = null; if ( obj.releaseCapture ) &#123; obj.releaseCapture(); &#125; &#125; return false; &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;img src=\"1.jpg\" id=\"img1\" /&gt;&lt;/body&gt;&lt;/html&gt; 三.碰撞检测1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768window.onload = function() &#123; var oDiv = document.getElementById('div1'); var oImg = document.getElementById('img1'); drag(oDiv); function drag(obj) &#123; obj.onmousedown = function(ev) &#123; var ev = ev || event; var disX = ev.clientX - this.offsetLeft; var disY = ev.clientY - this.offsetTop; if ( obj.setCapture ) &#123; obj.setCapture(); &#125; document.onmousemove = function(ev) &#123; var ev = ev || event; var L = ev.clientX - disX; var T = ev.clientY - disY; var L1 = L; var R1 = L + obj.offsetWidth; var T1 = T; var B1 = T + obj.offsetHeight; var L2 = oImg.offsetLeft; var R2 = L2 + oImg.offsetWidth; var T2 = oImg.offsetTop; var B2 = T2 + oImg.offsetHeight; if ( R1 &lt; L2 || L1 &gt; R2 || B1 &lt; T2 || T1 &gt; B2 ) &#123; oImg.src = '1.jpg'; &#125; else &#123; oImg.src = '2.jpg'; &#125; obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125; document.onmouseup = function() &#123; document.onmousemove = document.onmouseup = null; if ( obj.releaseCapture ) &#123; obj.releaseCapture(); &#125; &#125; return false; &#125; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;img src=\"1.jpg\" id=\"img1\" /&gt;&lt;/body&gt;&lt;/html&gt; 四.模拟个滚动条控制内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768window.onload = function() &#123; var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); var oDiv4 = document.getElementById('div4'); var iMaxTop = oDiv1.offsetHeight - oDiv2.offsetHeight; oDiv2.onmousedown = function(ev) &#123; var ev = ev || event; var disY = ev.clientY - this.offsetTop; document.onmousemove = function(ev) &#123; var ev = ev || event; var T = ev.clientY - disY; if ( T &lt; 0 ) &#123; T = 0; &#125; else if ( T &gt; iMaxTop ) &#123; T = iMaxTop; &#125; oDiv2.style.top = T + 'px'; var iScale = T / iMaxTop; document.title = iScale; oDiv4.style.top = (oDiv3.clientHeight - oDiv4.offsetHeight) * iScale + 'px'; &#125; document.onmouseup = function() &#123; document.onmousemove = document.onmouseup = null; &#125; return false; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=\"div3\"&gt; &lt;div id=\"div4\"&gt; 搜索设置|百度首页|登录注册新闻 网页 贴吧 知道 音乐 图片 视频 地图 文库 更多»推荐 : 用手机随时随地上百度其他人还搜烤鱼动搜索的结果，不代表百度赞成被搜索网站的内容或立场 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"js操作节点","date":"2017-04-22T14:48:52.312Z","path":"2017/04/22/jsdom/","text":"一.概念元素对象：在html dom中，元素对象代表着一个html元素，也就是元素对象是标签元素对象的子节点：可以是元素节点，文本节点，注释节点NodeList对象：代表了节点列表 二.元素常用的的属性和方法element.attributes 返回一个元素的属性数组 element.classlist 返回元素的类名，作为 DOMTokenList 对象。classList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。element.className 设置或返回元素的class属性element.childNodes 返回元素的一个子节点的数组element.firstChild 返回元素的第一个子节点element.lastChild 返回的最后一个子元素element.nextSibling 返回该元素紧跟的一个节点element.parentNode 返回元素的父节点element.previousSibling 返回某个元素紧接之前元素element.appendChild() 为元素添加一个新的子元素element.insertBefore() 现有的子元素之前插入一个新的子元素element.removeChild() 删除一个子元素element.replaceChild() 替换一个子元素 element.cloneNode() 克隆某个元素element.focus() 设置文档或元素获取焦点 element.getAttributeNode() 返回指定属性节点element.getElementsByTagName() 返回指定标签名的所有子元素集合。element. getElementsByClassName() 返回文档中所有指定类名的元素集合，作为 NodeList 对象。 element.querySelector() 返回匹配指定 CSS 选择器元素的第一个子元素document.querySelectorAll() 返回匹配指定 CSS 选择器元素的所有子元素节点列表 element.removeAttribute() 从元素中删除指定的属性element.setAttribute() 设置或者改变指定属性并指定值。element.getAttribute() 返回指定元素的属性值用.和[]的形式无法操作元素的自定义属性getAttribute可以操作元素的自定义属性 element.addEventListener() 向指定元素添加事件句柄element.removeEventListener() 移除由 element.clientHeight 在页面上返回内容的可视高度（不包括边框，边距或滚动条）element.clientWidth 在页面上返回内容的可视宽度（不包括边框，边距或滚动条）element.scrollHeight 返回整个元素的高度（包括带滚动条的隐蔽的地方）element.scrollLeft 返回当前视图中的实际元素的左边缘和左边缘之间的距离element.scrollTop 返回当前视图中的实际元素的顶部边缘和顶部边缘之间的距离element.scrollWidth 返回元素的整个宽度（包括带滚动条的隐蔽的地方） element.offsetHeight 返回，任何一个元素的高度包括边框和填充，但不是边距element.offsetWidth 返回元素的宽度，包括边框和填充，但不是边距element.offsetLeft 返回当前元素的相对水平偏移位置的偏移容器element.offsetParent 返回元素的偏移容器element.offsetTop 返回当前元素的相对垂直偏移位置的偏移容器 三.parentNode和offsetParent的区别element.parentNode：只读属性，指当前元素的父级节点offsetParent：只读 属性 离当前元素最近的一个有定位属性的父节点如果没有定位父级，默认是body，有兼容性问题。 经过测试parentNode没有什么兼容性问题，可以大胆使用。offsetParent：只读 属性 离当前元素最近的一个有定位属性的父节点如果没有定位父级，默认是bodyIe7以下，如果当前元素没有定位默认是body，如果有定位则是htmlIe7以下，如果当前元素的某个父级触发了layout，那么offsetParent就会被指 向到这个触发了layout特性的父节点上 四. children和childNodes 的区别 childNodes 属性，标准的element.childNodes 返回元素的一个子节点的数组,包括HTML节点，所有属性节点，文本节点可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。 标准下：包含了文本和元素类型的节点，也会包含非法嵌套的子节点 非标准下：只包含元素类型的节点，ie7以下不会包含非法嵌套子节点 children 属性，非标准的，它返回指定元素的子元素集合。经测试，它只返回HTML节点，甚至不返回文本节点 五.firstChild与firstElementChild 元素.firstChild : 只读 属性 第一个子节点标准下：firstChild会包含文本类型的节点 非标准下：只包含元素节点 元素.firstElementChild : 只读 属性 标准下获取第一个元素类型的子节点 兼容方式：var oFirst = oUl.firstElementChild || oUl.firstChild;var oLast = oUl.lastElementChild || oUl.lastChild;var oNext = oFirst.nextElementSibling || oFirst.nextSibling;var oPrev = oLast.previousElementSibling || oLast.previousSibling; 六.offsetTop等元素.offsetLeft[Top] : 只读 属性 当前元素到定位父级的距离（偏移值） 到当前元素的offsetParent的距离 如果没有定位父级 offsetParent -&gt; body offsetLeft -&gt; html 如果有定位父级 ie7以下：如果自己没有定位，那么offsetLeft[Top]是到body的距离 如果自己有定位，那么就是到定位父级的距离 其他：到定位父级的距离 七.offsetWidth与clientWidth与scrollHeightalert( oDiv.style.width ); //100 alert( oDiv.clientWidth ); //样式宽 + padding 120 也就是说只与oDiv有关，如果子元素比他宽也不管 alert( oDiv.offsetWidth ); //样式宽 + padding + border 可视区宽 + 边框 122 scrollHeight : 内容实际宽高//高+padding+border 不仅与oDiv有关还与子元素的宽有关，如果子元素比oDiv宽 123456789101112131415var oDiv1 = document.getElementById('div1'); //scrollHeight : 内容实际宽高 alert(oDiv1.scrollHeight);//812 alert(oDiv1.clientHeight);//140 alert(oDiv1.style.Height);//undefined alert(oDiv1.offsetHeight);//142body style=\"height:2000px;\"&gt; &lt;div id=\"div1\" style=\"width:120px;height:120px;border: 1px solid red; overflow: -auto; padding: 10px;\"&gt; &lt;div style=\"height: 800px;width: 100px; background: red;border: 1px solid green;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 五.文档对象模型的概念DOM : Document Object Model 文档对象模型文档：html页面文档对象：页面中元素文档对象模型：定义 为了能够让程序(js)去操作页面中的元素 DOM会把文档看作是一棵树，同时定义了很多方法来操作这棵数中的每一个元素（节点） 八.如何判断是不是ieif ( window.navigator.userAgent.indexOf(‘MSIE’) != -1 ) { alert(‘我是ie’);} else { alert(‘我不是ie’);} window.locationwindow.location.href = window.location内容window.location.search = url?后面的内容window.location.hash = url#后面的内容 十.attatchEvent与addEventListenerie：obj.attachEvent(事件名称，事件函数); 1.没有捕获 2.事件名称有on 3.事件函数执行的顺序：标准ie-》正序 非标准ie-》倒序 4.this指向window标准：obj.addEventListener(事件名称，事件函数，是否捕获); 1.有捕获 2.事件名称没有on 3.事件执行的顺序是正序 4.this触发该事件的对象","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"关于时间和时间戳","date":"2017-04-22T08:06:51.131Z","path":"2017/04/22/time/","text":"一.时间对象Date数字的形式：new Date(2013,4,14,9,45,20);//页就是年月日时分秒字符串的形式：new Date(‘November 27,2013 22:3:0’);//只有一个逗号，前面写月日，后面写年 时分秒，注意空格字符串的形式：new Date(“2014-07-19 20:10:1”); 未来时间与现在时间的差：var inow=new Date();var iNew=new Date(November 27,2017 20:16:0); var t=Math.floor((inow-iNew)/1000); 天：Math.floor(t/86400)时：Math.floor(t%86400/3600)分：Math.floor(t%86400%3600/60)秒：t%60 二.时间戳概念：从1970年1月1日至今的毫秒数，可以通过getTime()得到注意是毫秒有时候给出的时间戳是秒 获取当前时间的时间戳的方法： 1.var timestamp=Date.parse(new Date()); 2.var timestamp=(new Date()).valueOf(); 3.var timestamp=new Date().getTime(); 第一种：获取的时间戳是把毫秒改成000显示， 第二种和第三种是获取了当前毫秒的时间戳。 三.Date对象下的时间转化为字符串的方法12345var inow=new Date();console.log(inow.toString());//Sat Apr 22 2017 17:18:20 GMT+0800 (中国标准时间)console.log(inow.toLocaleString());//2017/4/22 下午5:18:20console.log(inow.toLocaleTimeString());//下午5:18:20console.log (inow.toLocaleDateString());//2017/4/22 四.时间戳转化为其他形式日期的写法123var inow=new Date();console.log(inow.toLocaleString().replace(/上午|下午/g,''));//2017/4/22 10:19:05console.log(inow.toLocaleString().replace(/上午|下午/g,'').replace(/\\//g,'-'));//2017-4-22 10:21:54 五.一些常用的时间对象的函数 getDate()返回月中的天 getDay()周中的星期几 getFullYear()四位以上数字的年份 getHours()时 getMinuters()分 getSeconds()秒 getMonth()月以上函数都有对应的set函数setDate() 设置 Date 对象中月的某一天 (1 ~ 31)。setFullYear() 设置 Date 对象中的年份（四位数字）。setHours() 设置 Date 对象中的小时 (0 ~ 23)。setMinutes() 设置 Date 对象中的分钟 (0 ~ 59)。setMonth() 设置 Date 对象中月份 (0 ~ 11)。setSeconds() 设置 Date 对象中的秒钟 (0 ~ 59)。setTime() setTime() 方法以毫秒设置 Date 对象。","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"domove和setOpacity和shake的封装","date":"2017-04-22T07:40:10.624Z","path":"2017/04/22/domoveAndSetOpacity/","text":"123456789101112131415161718192021222324252627282930function doMove ( obj, attr, dir, target, endFn ) &#123; dir = parseInt(getStyle( obj, attr )) &lt; target ? dir : -dir; clearInterval( obj.timer ); obj.timer = setInterval(function () &#123; var speed = parseInt(getStyle( obj, attr )) + dir; // 步长 if ( speed &gt; target &amp;&amp; dir &gt; 0 || speed &lt; target &amp;&amp; dir &lt; 0 ) &#123; speed = target; &#125; obj.style[attr] = speed + 'px'; if ( speed == target ) &#123; clearInterval( obj.timer ); /* if ( endFn ) &#123; endFn(); &#125; */ endFn &amp;&amp; endFn(); &#125; &#125;, 30);&#125; 1234567891011121314151617181920212223242526272829303132function setOpacity(element, transparency, speed, callback)&#123;//透明度渐变：transparency:透明度 0(全透)-100(不透)；speed:速度1-100，默认为1 if(typeof(element)=='string')element=document.getElementById(element); if(!element.effect)&#123; element.effect = &#123;&#125;; element.effect.fade=0; &#125; clearInterval(element.effect.fade); var speed=speed||1; var start=(function(elem)&#123; var alpha; if(navigator.userAgent.toLowerCase().indexOf('msie') != -1)&#123; alpha=elem.currentStyle.filter.indexOf(\"opacity=\") &gt;= 0?(parseFloat( elem.currentStyle.filter.match(/opacity=([^)]*)/)[1] )) + '': '100'; &#125;else&#123; alpha=100*elem.ownerDocument.defaultView.getComputedStyle(elem,null)['opacity']; &#125; return alpha; &#125;)(element); if(window.console&amp;&amp;window.console.log)console.log('start: '+start+\" end: \"+transparency); element.effect.fade = setInterval(function()&#123; start = start &lt; transparency ? Math.min(start + speed, transparency) : Math.max(start - speed, transparency); element.style.opacity = start / 100; element.style.filter = 'alpha(opacity=' + start + ')'; if(Math.round(start) == transparency)&#123; element.style.opacity = transparency / 100; element.style.filter = 'alpha(opacity=' + transparency + ')'; clearInterval(element.effect.fade); if(callback)callback.call(element); &#125; &#125;, 20); &#125; 123456789101112131415161718192021function shake ( obj, attr, endFn ) &#123; var pos = parseInt( getStyle(obj, attr) ); var arr = []; // 20, -20, 18, -18 ..... 0 var num = 0; var timer = null; for ( var i=20; i&gt;0; i-=2 ) &#123; arr.push( i, -i ); &#125; arr.push(0); clearInterval( obj.shake ); obj.shake = setInterval(function ()&#123; obj.style[attr] = pos + arr[num] + 'px'; num++; if ( num === arr.length ) &#123; clearInterval( obj.shake ); endFn &amp;&amp; endFn(); &#125; &#125;, 50);&#125;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"js获取样式的兼容方法","date":"2017-04-22T07:19:05.724Z","path":"2017/04/22/getstyle/","text":"123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div&#123; color:yellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"width:100px;height:100px;background-color:red\"&gt;This is div&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 一.通过style属性获取，但是只能获取行内样式12345&lt;script&gt; var div = document.getElementsByTagName(\"div\")[0]; console.log(div.style.color); //\"\" console.log(div.style.backgroundColor); //red&lt;/script&gt; 由于element.style是元素的属性，我们可以对属性重新赋值来改写元素的显示。 二.getComputedStyle和currentStyle来获取,而getComputedStyle和currentStyle是只读的getComputedStyle的使用环境是chrome/safari/firefox IE 9,10,11 currentStyle在IE里能得到完美支持，chrome不支持，ff不支持所以兼容写法如下:123function getStyle( obj, attr )&#123; return obj.currentStyle ? obj.currentStyle[attr] : getComputedStyle( obj )[attr];&#125;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"js解析器解析变量和函数","date":"2017-04-22T06:59:50.868Z","path":"2017/04/22/jsjiexiqi/","text":"js解析器是如何解析代码的第一步：“找一些东西” ：var function 参数如何解析:a = … 所有的变量，在正式运行代码之前，都提前赋了一个值：未定义fn1 = function fn1(){ alert(2); } 所有的函数，在正式运行代码之前，都是整个函数块 JS 的预解析 遇到重名的：只留一个变量和函数重名了，就只留下函数 第二步：逐行解读代码：表达式：= + - * / % ++ -- ! 参数…… 表达式可以修改预解析的值！ 123456789101112alert(a); // function a ()&#123; alert(4); &#125;var a = 1;alert(a); // 1function a ()&#123; alert(2); &#125;alert(a); // 1var a = 3; alert(a); // 3function a ()&#123; alert(4); &#125;alert(a); // 3alert( typeof a );// a(); // 报错 123456789101112131415var a = 1;function fn1()&#123; alert(a); // undefined var a = 2;&#125;fn1();alert(a); // 1var a = 1;function fn1()&#123; alert(a); // 1 a = 2;&#125;fn1();alert(a); // 2","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"头部信息header","date":"2017-04-21T08:09:24.858Z","path":"2017/04/21/headresorce/","text":"http头域有：请求头，响应头，实体头，通用头 1.通用头部是客户端和服务器都可以使用的头部可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能，如Date头部。 2.请求头部是请求报文特有的，它们为服务器提供了一些额外信息，比如客户端希望接收什么类型的数据，如Accept头部 3.响应头部便于客户端提供信息，比如，客服端在与哪种类型的服务器进行交互，如Server头部 4.实体头部指的是用于应对实体主体部分的头部，比如，可以用实体头部来说明实体主体部分的数据类型，如Content-Type头部。 一些常用头的介绍 通用头 1.Cache-Control:指定请求和响应遵循的缓存机制 no-cache：指示请求或响应消息不能缓存no-store：缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息 2、Pragma Pragma头域用来包含实现特定的指令，最常用的是Pragma:no-cache。在HTTP/1.1协议中，它的含义和Cache- Control:no-cache相同。 3、ConnectionConnection表示是否需要持久连接 4.DateDate表示消息发送的时间,服务器响应中要包含这个头部 请求头：说明是谁在发送什么请求，源于何处，或者喜好，便于服务器更好的提供服务 1.Accept代表发送端（客户端）希望接受的数据类型，比如：Accept：text/xml;代表客户端希望接受的数据类型是xml类型 2.Accept-Language：浏览器申明自己接收的语言 3.Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn 4.User-Agent 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14 响应头：响应头向客户端提供一些额外的信息，比如谁在发送响应，响应者的功能，与响应相关的一些特殊指令，这些头部有助于客户端处理响应，并在将来发起更好的请求 1.age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 2.Server：web服务器的版本，软件，等信息，例如：Server：Apache/2.0.61 (Unix) 3.Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。实体头：实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。请求消息和响应消息都可以包含实体信息 1.Allow：服务器支持哪些请求方法（如GET、POST等）。 2.Location：表示客户应当到哪里去提取文档 3.Content-Type：代表发送端（客户端|服务器）发送的实体数据的数据类型。","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"面向对象，原型，继承","date":"2017-04-20T14:44:31.387Z","path":"2017/04/20/prototype/","text":"js面向对象的几种模式一：普通模式1234567var obj = new Object(); //创建了一个空的对象obj.name = '小明'; //属性obj.showName = function()&#123; //方法 alert(this.name);&#125;;obj.showName(); 一次只能创建一个 二：工厂模式1234567891011121314151617181920//工厂方式 : 封装函数function createPerson(name)&#123; //1.原料 var obj = new Object(); //2.加工 obj.name = name; obj.showName = function()&#123; alert( this.name ); &#125;; //3.出场 return obj; &#125;var p1 = createPerson('小明');p1.showName();var p2 = createPerson('小强');p2.showName(); 缺点：每个对象都有一份自己的属性和方法 三：原型模式12345678910111213141516171819//当new去调用一个函数 : 这个时候函数中的this就是创建出来的对象,而且函数的的返回值直接就是this啦(隐式返回)//new后面调用的函数 : 叫做构造函数function CreatePerson(name)&#123; this.name = name; &#125;CreatePerson.prototype.showName = function()&#123; alert( this.name );&#125;;var p1 = new CreatePerson('小明');//p1.showName();var p2 = new CreatePerson('小强');//p2.showName();alert( p1.showName == p2.showName ); //true 注意： A.在27行中的结果是true，因为原型在内存中只有一份 B.当new去调用一个函数 : 这个时候函数中的this就是创建出来的对象,而且函数的的返回值直接就是this啦(隐式返回) C.new后面调用的函数 : 叫做构造函数 一些常用的函数： 1.hasOenProperty:查看是不是对象自身下面的属性 123456789//hasOwnProperty : 看是不是对象自身下面的属性var arr = [];arr.num = 10;Array.prototype.num2 = 20;//alert( arr.hasOwnProperty('num') ); //truealert( arr.hasOwnProperty('num2') ); //false 2.constructor:查看对象的构找函数 12345678910111213141516function Aaa()&#123;&#125;var a1 = new Aaa();alert( a1.constructor ); //Aaavar arr = [];alert( arr.constructor == Array ); //true*/function Aaa()&#123;&#125;Aaa.prototype.constructor = Aaa; //每一个函数都会有的，都是自动生成的Aaa.prototype.constructor = Array; constructor是在当前对象的原型下的属性 3.instanceof:对象与构造函数在原型链上是否有关系 12345678910111213//instanceof : 对象与构造函数在原型链上是否有关系function Aaa()&#123;&#125;var a1 = new Aaa();//alert( a1 instanceof Object ); //truevar arr = [];alert( arr instanceof Array ); 4.toString:把对象转换成字符串123456789toString() : 系统对象下面都是自带的 , 自己写的对象都是通过原型链找object下面的var arr = [];alert( arr.toString == Object.prototype.toString ); //falsefunction Aaa()&#123;&#125;var a1 = new Aaa();alert( a1.toString == Object.prototype.toString ); //true* 也就是说如果是自通对象，比如arr，toString就是在Array下面自带的而自己写的对象比如a1，toString在object的原型下。 注意：toString是最完美的类型判断的方法1234567891011121314151617181920212223//利用toString做类型的判断 : /*var arr = [];alert( Object.prototype.toString.call(arr) == '[object Array]' ); */ //'[object Array]'window.onload = function()&#123; var oF = document.createElement('iframe'); document.body.appendChild( oF ); var ifArray = window.frames[0].Array; var arr = new ifArray(); //alert( arr.constructor == Array ); //false //alert( arr instanceof Array ); //false alert( Object.prototype.toString.call(arr) == '[object Array]' ); //true &#125;; 五:拷贝继承继承：子类不影响父类，子类可以继承父类的一些功能（代码复用）属性的继承：调用父类的构造函数call方法的继承：for in：拷贝继承（jqurey也是采用拷贝继承extend）12345678910111213141516171819202122232425262728293031323334353637function CreatePerson(name,sex)&#123; //父类 this.name = name; this.sex = sex;&#125;CreatePerson.prototype.showName = function()&#123; alert( this.name );&#125;;var p1 = new CreatePerson('小明','男');//p1.showName();function CreateStar(name,sex,job)&#123; //子类 CreatePerson.call(this,name,sex); this.job = job; &#125;//CreateStar.prototype = CreatePerson.prototype;extend( CreateStar.prototype , CreatePerson.prototype );CreateStar.prototype.showJob = function()&#123;&#125;;var p2 = new CreateStar('黄晓明','男','演员');p2.showName();function extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr] = obj2[attr]; &#125;&#125; 看一个例子：123456var a=&#123; name:'xiaoming'&#125;;var b=a;//b引用了ab.name='xiaoqiang';alert(a.name);//xiaoqiang 因为b是a的引用，为了解决这个问题123456789var b=&#123;&#125;;extend(b,a);b.name='xiaoqiang';alert(a.name);//xiaomingfunction extend(obj1,obj2)&#123; for(var attr in obj2)&#123; obj1[attr]=obj2[attr]; &#125;&#125; 这样写就是复制而不是引用 五：类式继承123456789101112function Aaa()&#123; this.name='小明';&#125;Aaa.prototype.showName=function()&#123; alert(this.name);&#125;function Bbb()&#123;&#125;Bbb.prototype=new Aaa();//这句话就是类式继承var b1=new Bbb();b1.showName();alert(b1.name);//小明 面试题：如何用一句话做到继承，指的就是类似继承，但是有很多问题，比如改变了b1的constructor指向，为了解决这个问题加一句话Bbb.prototype.constructor=Bbb;但是还是有很多问题类似继承最好是属性和方法分开继承 属性的继承：123function Bbb()&#123; Aaa.call(this);&#125; 方法的继承：1234var F=function()&#123;&#125;;F.prototype=Aaa.prototype;Bbb.prototype=new F();Bbb.prototype.constructor=Bbb; 这才是完美结类式继承 六.原型 与原型链的概念原型：我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法原型链：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针，如果我们用原型对象等于另一个类型的实例，那么此时原型对象将包含一个指向另一个原型的指针相应的另一个原型中也包含一个指向另一个构造函数的指针，以此类推，层层递进就构成了实例与原型的链条，这叫原型链","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"JS中some(),every(),forEach(),map(),filter()区别","date":"2017-04-20T08:52:44.530Z","path":"2017/04/20/Array/","text":"JS在1.6中为Array新增了几个方法map()，filter()，some()，every()，forEach()，也就是一共有这么多方法了。 1、map():返回一个新的数组，每个元素为调用func的结果 2、filter():检测数值元素，并返回符合条件所有元素的数组。 3、some():返回一个boolean值，判断是否有元素符合func 4、every():返回一个boolean值，判断是否每个元素都符合func 5、forEach():没有返回值，只是每个元素都执行一次func map():返回一个新的数组，每个元素为调用func后的返回值12345678var numbers = [4, 9, 16, 25];function myFunction() &#123; x = document.getElementById(\"demo\") x.innerHTML = numbers.map(Math.sqrt);&#125;//[2,3,4,5] filter():检测数值元素，并返回符合条件所有元素的数组,看元素是否符合return后面那句话。该方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 参数说明：array.filter(function(currentValue,index,arr), thisValue) 参数 描述currentValue 必须。当前元素的值index 可选。当期元素的索引值arr 可选。当期元素属于的数组对象 thisValue12345678910var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(\"demo\").innerHTML = ages.filter(checkAdult);&#125;//[32,33,40] ## every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。every() 方法使用指定函数检测数组中的所有元素：如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true。1234567891011var ages = [32, 33, 16, 40];function checkAdult(age) &#123; return age &gt;= 18;&#125;function myFunction() &#123; document.getElementById(\"demo\").innerHTML = ages.every(checkAdult);&#125;//false jq中的filter方法返回符合一定条件的元素，该方法让您规定一个条件。不符合条件的元素将从选择中移除，符合条件的元素将被返回。$(selector).filter(criteria,function(index)) 参数 描述criteria 可选。规定要从被选元素组合中返回的选择器表达式、jQuery 对象、一个或多个元素。function(index) 可选。为集合中的每个元素规定要运行的函数。如果返回 true，则保留元素，否则元素将被移除。index - 集合中元素的 index 位置。注意： this 是当前的 DOM 元素。 jq中each() 方法为每个匹配元素规定要运行的函数。$(selector).each(function(index,element)) 参数 描述function(index,element) 必需。为每个匹配元素规定运行的函数。index - 选择器的 index 位置。element - 当前的元素（也可使用 “this” 选择器）。 jq中map()把当前匹配集合中的每个元素传递给函数，产生包含返回值的新 jQuery 对象","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"react","date":"2017-04-20T05:13:06.971Z","path":"2017/04/20/react/","text":"阮一峰老师的react入门教程 一.react简介 react最主要有三个核心库react.js react-dom.js browser.js他们必须首先被加载才能使用。react.js为核心库，react-dom.js提供dom相关操作，brower.js的作用是把jsx语法转化为javasript语法 react允许将代码封装成组件，然后像插入普通HTML标签一样，在网页中插入这个组件 组件并不是真实的dom节点，而是存在于内存中的一种数据结构，叫虚拟dom，只有当它插入文档以后才会变成真实的dom，根据react的设计，所有dom的变化都先在虚拟dom上发生，然后再将实际发生的部分反映到真实dom上，这种算法叫做dom diff，它可以极大的提高性能的表现 需要用ref属性来获取真实的dom节点 react的创新在于将组建看成是一个状态机，一开始有一个初始状态，用户互动导致状态变化，从而触发重新渲染UI 二.react使用的注意事项 1.组件名第一个字母大写 2.组件只包含一个顶层标签，也就是render方法里面要用一个标签包含所有的标签 3.class写成className 4.事件写成驼峰式onKeyUp 5.单项数据流，只能从父组件流入子组件 6.props不可改变 7.事件的目标通过ev.target得到 8.ref获取真实dom节点 三.组件的通信 父组件可以通过props属性与子组件通信 子组件通过订阅发布的形式与父组件通信，父组件订阅（组件渲染完成之后触发componentDidMount），子组件发布 1234567891011//订阅PubSub.subscribe(\"delectItem\",function(evName,_id)&#123;&#125;)//发布delectItem:function()&#123; PubSub.publish(\"delectItem\",id)&#123; &#125;&#125; 四.生命周期组件的生命周期分为3个部分：（1）实例化 （2）存在期 （3）销毁 实例化阶段：实例化过程是完成虚拟dom和真实dom的生成这个阶段的方法：(排好序的) 1.getDefaultProps：这个发生在调用React.createClass的时候，该方法返回一个对象，与父组件指定的props合并，最后赋值给this.props 2.getInitialState：初始化state，调用一次 3.componentWillMount：完成首次渲染之前被调用，这也是render方法调用前可以修改state的最后机会 4.render：生成虚拟dom，此时不能改变组件状态 5.componentDidMount：render调用成功，真实dom已经被渲染之后 存在期通过实例化后可以与用户交互的阶段这个阶段的方法：(排好序的) 1.componentWillReceiveProps：组件的props可以通过父辈组件来改变，当接到新的props的触发 2.shouldComponentUpdate：做出要不要更新render的决定，该方法用来拦截新的props和state 3.componentWillUpdate：在接收到新的props和state之后，shouldComponentUpdate之后，再次render之前 4.render：生成页面需要的虚拟DOM结构，并返回该结构 5.componentDidUpdate：完成更新的渲染之后 销毁componentWillUnmount()在组件从DOM 中移除的时候立刻被调用","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"ajax的过程","date":"2017-04-16T15:13:12.031Z","path":"2017/04/16/ajax/","text":"ajax的过程一.创建XMLHttpRequest对象ie浏览器和其他浏览器有差别为了兼容该做如下写法12345if(window.XMLHttpRequest)&#123; var xhr=new XMLHttpRequest();&#125;else&#123; var xhr=new ActiveXObject();&#125; 二.设置响应HTTP请求状态变化的函数发送HTTP请求的目的是为了接收从服务器中返回的数据。从创建XMLHttpRequest对象开始，到发送数据、接收数据、XMLHttpRequest对象一共会经历以下5中状态 ⑴未初始化状态。在创建完XMLHttpRequest对象时，该对象处于未初始化状态，此时XMLHttpRequest对象的readyState属性值为0。 ⑵初始化状态。在创建完XMLHttpRequest对象后使用open()方法创建了HTTP请求时，该对象处于初始化状态。此时XMLHttpRequest对象的readyState属性值为1。 ⑶发送数据状态。在初始化XMLHttpRequest对象后，使用send()方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest对象的readyState属性值为2。 ⑷接收数据状态。Web服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest对象处于接收数据状态，XMLHttpRequest对象的readyState属性值为3。 ⑸完成状态。XMLHttpRequest对象接收数据完毕后，进入完成状态，此时XMLHttpRequest对象的readyState属性值为4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用responseText属性或responseXml属性来获取数据。 只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态。 XMLHttpRequest对象可以响应readystatechange事件，该事件在XMLHttpRequest对象状态改变时（也就是readyState属性值改变时）激发。因此，可以通过该事件调用一个函数，并在该函数中判断XMLHttpRequest对象的readyState属性值。如果readyState属性值为4则使用responseText属性或responseXml属性来获取数据 XMLHttpRequest对象的三个重要的属性： 1.onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 2.readyState存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 3.status 200: “OK”404: 未找到页面 一般框架是这样写的1234567xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;//在这里对请求回来的数据进行处理 &#125; &#125; 服务器常用的状态码及其对应的含义：（感觉笔试老会考到） 200：服务器响应正常。 304：该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。 400：无法找到请求的资源。 401：访问资源的权限不够。 403：没有权限访问资源。 404：需要访问的资源不存在。 405：需要访问的资源被禁止。 407：访问的资源需要代理身份验证。 414：请求的URL太长。 500：服务器内部错误。 三.向服务器发送请求使用open和send方法发送请求 open：规定请求的类型，url以及是否异步处理请求open(method,url,async):method为请求类型get和posturl：文件在服务器上的位置 async：true异步，false同步 send: 将请求发送到服务器 send（string）：string：仅仅用于post请求get还是post？ 与post比get更快更简单，大部分情况都能用 下面情况只能用post： 无法使用缓存文件(更新服务器上的文件或数据库) 向服务器发送大量数据(post没有数据限制) 发送包含为知字符的用户输入时，post比get更稳定可靠 对于post请求，如果希望像表单那样post数据，使用setRequestHeader()来添加HTTP头，然后在send方法中规定发送的数据123xmlhttp.open(\"POST\",\"/try/ajax/demo_post2.php\",true);xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");xmlhttp.send(\"fname=Henry&amp;lname=Ford\"); setRequestHeader(header,value) :向请求添加 HTTP 头。header: 规定头的名称value: 规定头的值","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"如何解决div里面img图片下方有空白的问题","date":"2017-04-14T12:40:24.288Z","path":"2017/04/14/img/","text":"一.问题：相信网站前端开发者可能会遇到这样的问题，&lt;div&gt;&lt;img src=&quot;picture.png&quot;/&gt;&lt;/div&gt; 这样的格式在html5的文档标准下会有一段空白区域，那么怎样去掉这部分空白区域呢？ 二.原因 首先我们要知道这部分空白产生的原因。图片默认的vertical-align是baseline， 也就是字母x的下边距，我们在图片后面写上x就是这样 可以看到图片是与字母x的下边距对齐的，也就是baseline，css2的文档中有这么一句解释，翻译过来也就是一个inline-block元素，如果里面没有inline元素，或者overflow不是visible，则该元素的基线就是其margin底边缘，否则，其基线就是元素里面最后一行内联元素的基线 三.解决方法 1.所以我们只需要将img图片display:block，即可去掉div和img之间的空白 2.或者将div的line-height设置得足够小，也可以去掉空白，例如div{line-height:5px;} 3.也可以将font-size设为0，实际上也是改变了line-height 4.当然，我们可以改变vertical-align，让它不是baseline，比如设置vertical-align:middle","tags":[{"name":"css","slug":"css","permalink":"http://liumeilian.com.cn/tags/css/"}]},{"title":"xxs和cors","date":"2017-04-13T14:10:04.579Z","path":"2017/04/13/XXS/","text":"一.xxs什么是xxsxxs叫跨域脚本攻击，它指的是攻击者往web页面里插入恶意html代码，当用户浏览该页面时，嵌入web里的html代码会被执行，从而达到恶意攻击用户的目的 为什么会产生xss原因是过滤不严 xss类型 反射式xss 这种xss，跨域代码一般会存在于某个链接中，当被攻击者访问这个链接时，跨域代码就没执行，这类跨域代码一般不会存储在服务器上 存储型XSS 跨域代码会存储在服务器上面的数据库中，所以可以进行持久攻击 基于DOM的xss这是由于客户端脚本自身的解析不正确导致的安全问题 反射型Xss的攻击原理它通过给别人发送带有恶意脚本代码参数的URL，当URL地址呗打开，特有的恶意代码参数呗html解析，他的特点是非持久的用户点击链接才能引起比如： http://searchb.dangdang.com/?key=f&#39;,true,1);alert(1);// 常用测试方法：对整个输入（特别强调的是，整个HTTP请求都是输入，数据库取来的数据其实也是输入。HTTP请求包括GET、POST参数，COOKIE，URL，头部的REFERER等等）中每个地方都可以如下操作， 自己构造一个唯一的串，例如:myxsstestxxxx 将某个输入项（比如某个参数）替换为上面的串 查看HTTP相应中是否有这个串，并记录下来 根据HTML上下文决定，用哪种类型串来尝试，尝试攻击串，然后重新提交请求 如果能够找到相应的攻击串说明漏洞是存在的 这里的关键在于第四步，因为服务器端可能会做一些限制，比如encode或者长度限制，测试的时候需要想办法看看是否能绕过限制。 存储型XSS的攻击原理存储型就是攻击的脚本被存储到了数据库护着文件中，服务端（可能是别的应用或别的页面）在读取了存储的内容后回显了，这就是存储型这种情况用户打开页面就会看到 原理：xss代码被提交给网站-&gt;网站把xss代码存储进数据库-&gt;当页面再次被请求,服务端发送已经被植入XSS代码的数据给客户端-&gt;客户端执行XSS代码 DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞各种攻击的举例 ### dom-xss:1234567891011&lt;?phperror_reporting(0);$name = $_GET[\"name\"];?&gt;&lt;input id=\"text\" type=\"text\" value=\"&lt;?php echo $name;?&gt;\" /&gt;&lt;div id=\"print\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;var text = document.getElementById(\"text\"); var print = document.getElementById(\"print\");print.innerHTML = text.value; // 获取 text的值，并且输出在print内。这里是导致xss的主要原因。&lt;/script&gt; 如下方式触发 存储型XXs123456789101112131415&lt;?phperror_reporting(0);$name = $_GET[\"name\"];//连接服务器$conn = mysql_connect(\"127.0.0.1\",\"root\",\"\");//打开数据库mysql_select_db(\"test\",$conn);//执行SQLmysql_query(\"set names 'utf8'\");$sql_insert = \"insert into liuyan(id,content) values('$id','$name')\";$result = mysql_query($sql_insert,$conn);$sql_select = \"select * from liuyan\";$results = mysql_fetch_array(mysql_query($sql_select));echo $results[content];?&gt; 先通过http://localhost/2.php?name=%3Cscript%3Ealert(1)%3C/script%3E然后再访问http://localhost/2.php。即可触发存储型xss： 反射型1234&lt;?php$name = $_GET[\"name\"];?&gt;&lt;input type=\"text\" value=\"&lt;?php echo $name?&gt;\"&gt; 结果： xxs的防范一句话：对输入做严格的过滤。对输出检查，转义，替换 二.csrf攻击概念：强迫受害者的浏览器向一个容易受攻击的web应用发送请求，达到攻击者的目的分类：站内和站外站内：由于程序员滥用$_REQUEST类变量造成，一些敏感的操作本来四要求要求用户从表单提交发起POST请求传参给程 序，但是由于使用了$_REQUEST等变量，程序也接收GET请求传参，这样就给攻击者使用CSRF攻击创造了条件，一般攻击者只要把预测好的请求参数 放在站内一个贴子或者留言的图片链接里，受害者浏览了这样的页面就会被强迫发起请求站外：CSRF站外类型的漏洞其实就是传统意义上的外部提交数据问题，一般程序员会考虑给一些留言评论等的表单加上水印以防止SPAM问题，但是为了用户的体验 性，一些操作可能没有做任何限制，所以攻击者可以先预测好请求的参数，在站外的Web页面里编写javascript脚本伪造文件请求或和自动提交的表单 来实现GET、POST请求，用户在会话状态下点击链接访问站外的Web页面，客户端就被强迫发起请求","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"跨文档通信问题","date":"2017-04-13T02:26:13.700Z","path":"2017/04/13/cross/","text":"一.窗口跨域操作问题和postmessage的使用当父子页面在同一个域www.a.com下的时候，父子页面有包含关系，服页面通过iframe引入子页面这个时候可以用js在父页面中操作子页面的DoM元素，也可以在子页面中用js操作父页面 12345678910111213141516171819202122232425262728293031323334353637//www.a.com 下的1.iframe.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyIframe = document.getElementById('myframe'); oBtn.onclick = function() &#123; oMyIframe.contentWindow.document.body.style.background = 'red'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，改变2.iframe.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"2.iframe.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;//www.a.com下的2.iframe.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; parent.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这里是a.com下的2.iframe.html页面 &lt;input type=\"button\" value=\"点击我，改变1.iframe.html的背景色\" id=\"btn\" /&gt;&lt;/body&gt; 父页面操作子页面：如果我们要操作一个iframe里面的dom元素，首先要获取到iframe引入的页面的window,用contentWindow获取子页面操作父页面：window parent top都是window对象window : 当前窗口window对象parent : 父级窗口window对象top : 顶级窗口window对象 当一个页面通过通过window.open的方式打开另一个页面，且这两个页面在同一个域名www.a.com下的21234567891011121314151617181920212223242526272829303132333435363738//www.a.com下的3.window.open.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oBtn2 = document.getElementById('btn2'); var newWindow = null; oBtn.onclick = function() &#123; //window.open 返回被打开窗口的window对象 newWindow = window.open('4.window.open.html', '_blank'); &#125; oBtn2.onclick = function() &#123; newWindow.document.body.style.background = 'red'; &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，开启一个新的窗口打开4.window.open.html页面\" id=\"btn\" /&gt; &lt;input type=\"button\" value=\"点击我，改变4.window.open.html页面的背景色\" id=\"btn2\" /&gt;&lt;/body&gt;//www.a.com下的4.window.open.htm&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //window.opener : 通过window.open方法打开当前页面的窗口window window.opener.document.body.style.background = 'green'; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是a.com下的4.window.open.html页面 &lt;input type=\"button\" value=\"点击我，改变3.window.open.html页面的背景色\" id=\"btn\" /&gt;&lt;/body&gt; 可以通过window.open返回的window对象操作被打开的页面的Domwindow.opener : 通过window.open方法打开当前页面的窗口window可以通过window.opener操作打开当面页面的页面的Dom 当本页面和通过iframe包含的页面不在同一个域名下的时候，这样操作就会有跨域操作安全限制问题这是需要通过postmessage给另一个页面发送消息，当另一个页面接到某些消息让做一些操作 1234567891011121314151617181920212223242526272829303132//www.a.com下的6.postMessage.html&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); var oMyIframe = document.getElementById('myframe'); oBtn.onclick = function() &#123; oMyIframe.contentWindow.postMessage('1', 'http://www.b.com'); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"点击我，改变2.iframe.html的背景色\" id=\"btn\" /&gt; &lt;iframe id=\"myframe\" src=\"http://www.b.com/3.postMessage.html\"&gt;&lt;/iframe&gt;&lt;/body&gt;//www.b.com下的3.postMessage.html&lt;script&gt;window.onload = function() &#123; window.addEventListener('message', function(ev) &#123; if (ev.data == '1') &#123; document.body.style.background = 'red'; &#125; &#125;, false);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 这是b.com的postMessage.html页面&lt;/body&gt; postMessage使用的方法是 ：接收消息的窗口的window对象.postMessage()，注意是接收接收消息的窗口哦，第一个参数：发送的数据第二个参数：接收数据的域名｛带上协议｝ message事件的事件对象ev保存了发送过来的信息，ev.data就是发送过来的数据 二.ajax请求跨域文件问题当ajax请求的是另一个域下的文件时，出现跨域问题在标准浏览器下，XMLHttpRequest对象已经是升级版本，支持了更多的特性，可以跨域了但是，如果想实现跨域请求，还需要后端的相关配合才可以后端如何配合，比如www.a.com下的7.ajax.html通过ajax请求www.b.com下的ajax.php文件那么ajax.php文件加一句header(‘Access-Control-Allow-Origin:http://www.a.com‘); //这是允许访问该资源的域 IE如果想实现跨域请求，则需要使用另外一个对象XDomainRequest去实现 123456789101112131415161718192021222324252627282930313233//www.a.com下的7.ajax&lt;script&gt;window.onload = function() &#123; var oBtn = document.getElementById('btn'); oBtn.onclick = function() &#123; //标准浏览器下的跨域解决 var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; alert(xhr.responseText); &#125; &#125; &#125; xhr.open('get', 'http://localhost/miaov/HTML5-5/b/ajax.php', true); xhr.send(); //ie下的跨域解决 /* var oXDomainRequest = new XDomainRequest(); oXDomainRequest.onload = function() &#123; alert(this.responseText); &#125; oXDomainRequest.open('get', 'http://www.b.com/ajax.php', true); oXDomainRequest.send();*/ &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=\"button\" value=\"获取跨域下内容\" id=\"btn\" /&gt;&lt;/body&gt; 三.解决跨域问题的jsonp方法跨域：跨域名 一个域名下的文件去请求了和他不一样的域名下的资源文件，那么就会产生跨域请求 JSONP : JSON with Padding 1.script标签 2.用script标签加载资源是没有跨域问题的 如何解决：在资源加载进来之前定义好一个函数，这个函数接收一个参数（数据），函数里面利用这个参数做一些事情然后需要的时候通过script标签加载对应远程文件资源，当远程的文件资源被加载进来的时候，就会去执行我们前面定义好的函数，并且把数据当作这个函数的参数传入进去 举例：在客户端:在客户端用script请求，并且编写函数处理返回来的数据1234567891011121314function addScriptTag(src) &#123; var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script);&#125;window.onload = function () &#123; addScriptTag('http://example.com/ip?callback=foo');&#125;function foo(data) &#123; console.log(data);//test&#125;; 在服务端：把需要的数据用函数包裹起来1foo(\"test\"); 注意：基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求三.cors解决跨域问题cors详解 什么是CORSCORS（Cross-Origin Resource Sharing 跨源资源共享），当一个请求url的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域 CORS的安全隐患跨域请求和Ajax技术都会极大地提高页面的体验，但同时也会带来安全的隐患，其中最主要的隐患来自于CSRF（Cross-site request forgery）跨站请求伪造 CORS验证机制出于安全原因，浏览器限制从脚本中发起的跨域HTTP请求。默认的安全限制为同源策略， 即JavaScript或Cookie只能访问同域下的内容。W3C推荐了一种跨域的访问验证的机制，即CORS（Cross-Origin Resource Sharing 跨源资源共享）。这种机制让Web应用服务器能支持跨站访问控制，使跨站数据传输更加安全，减轻跨域HTTP请求的风险。CORS验证机制需要客户端和服务端协同处理。 客户端处理机制基于上述的CSRF的风险，各主流的浏览器都会对动态的跨域请求进行特殊的验证处理。验证处理分为： 简单请求验证处理 预先请求验证处理。 简单请求当请求同时满足下面两个条件时，浏览器会直接发送GET请求，在同一个请求中做跨域权限的验证。 请求方法是下列之一： GET HEAD POST请求头中的Content-Type请求头的值是下列之一： application/x-www-form-urlencoded(表单的默认提交数据的格式) multipart/form-data（需要在表单中进行文件上传时，就需要使用该格式） text/plain（希望发送端发送的数据的类型是plain，也就是空） 简单请求时，浏览器会直接发送跨域请求，并在请求头中携带Origin 的header，表明这是一个跨域的请求。服务器端接到请求后，会根据自己的跨域规则，通过Access-Control-Allow-Origin和Access-Control-Allow-Methods响应头，来返回验证结果。如果验证成功，则会直接返回访问的资源内容。如果验证失败，则返回403的状态码，不会返回跨域请求的资源内容。 预先请求当请求满足下面任意一个条件时，浏览器会先发送一个OPTION请求，用来与目标域名服务器协商决定是否可以发送实际的跨域请求。 请求方法不是下列之一： GET HEAD POST请求头中的Content-Type请求头的值不是下列之一： application/x-www-form-urlencoded multipart/form-data text/plain 浏览器在发现页面中有上述条件的动态跨域请求的时候，并不会立即执行对应的请求代码，而是会先发送Preflighted requests（预先验证请求），Preflighted requests是一个OPTION请求，用于询问要被跨域访问的服务器，是否允许当前域名下的页面发送跨域的请求。 OPTIONS请求头部中会包含以下头部：Origin、Access-Control-Request-Method、Access-Control-Request-Headers。服务器收到OPTIONS请求后，设置Access-Control-Allow-Origin、Access-Control-Allow-Method、Access-Control-Allow-Headers头部与浏览器沟通来判断是否允许这个请求。如果Preflighted requests验证通过，浏览器才会发送真正的跨域请求。 如果Preflighted requests验证失败，则会返回403状态，浏览器不会发送真正的跨域请求。 服务端处理机制服务器端对于跨域请求的处理流程如下： 1.首先查看http头部有无origin字段； 2.如果没有，或者不允许，直接当成普通请求处理，结束； 3.如果有并且是允许的，那么再看是否是preflight(method=OPTIONS)； 4.如果不是preflight（简单请求），就返回Allow-Origin、Allow-Credentials等，并返回正常内容。 5.如果是preflight（预先请求），就返回Allow-Headers、Allow-Methods等，内容为空；","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"layout和css的hack详解","date":"2017-04-12T08:35:42.295Z","path":"2017/04/12/layout/","text":"一.layout概念看了网上对于layout的各种说法，这里用一句话来总结layout的概念，这个概念仅仅是便于自己的理解，并非官方定义layout：layout是元素的一个属性，有些元素本省具有layout属性，有的元素需要通过设置某些css才能获得layout属性 一个元素是否具有“layout”可能会引发如下的一些问题： IE 很多常见的浮动 bug 。 元素本身对一些基本属性的异常处理问题。 容器和其子孙之间的边距重叠(margin collapsing)问题。 使用列表时遇到的诸多问题。 背景图像的定位偏差问题。 使用脚本时遇到的浏览器之间处理不一致的问题。 下列元素应该是默认具有 layout 的：, , , , , , , , , , 下列 CSS 属性和取值将会让一个元素获得 layout： position: absolute绝对定位元素的包含区块(containing block)就会经常在这一方面出问题。 float: left|right由于 layout 元素的特性，浮动模型会有很多怪异的表现。 display: inline-block当一个内联级别的元素需要 layout 的时候往往就要用到它，这也可能也是这个 CSS 属性的唯一效果——让某个元素拥有 layout。“inline-block行为”在IE中是可以实现的，但是非常与众不同： IE/Win: inline-block and hasLayout 。 width: 除 “auto” 外的任意值很多人遇到 layout 相关问题发生时，一般都会先尝试用这个来修复。 height: 除 “auto” 外的任意值 height: 1% 就在 Holly Hack 中用到。 zoom: 除 “normal” 外的任意值 (MSDN) IE6中很多Bug特别是定位问题都可以通过触发layout得到解决，以上的解决方法无论是设置zoom:1还是设置width和height其实都是为了触发layout。二.css HackCSS hack 概念CSS hack是通过在CSS样式中加入一些特殊的符号，让不同的浏览器识别不同的符号（什么样的浏览器识别什么样的符号是有标准的，CSS hack就是让你记住这个标准），以达到应用不同的CSS样式的目的简单地讲，css hack指各版本及各品牌浏览器之间对CSS解释后出现网页内容的误差(比如我们常说错位)的处理。由于各浏览器的内核不同，所以会造成一些误差就像JS一样，一个JS网页特效，在微软IE6、IE7、IE8浏览器有效果，但可能在火狐（Mozilla Firefox）谷歌浏览器无效，这样就叫做JS hack ，所以我们对于CSS来说他们来解决各浏览器对CSS解释不同所采取的区别不同浏览器制作不同的CSS样式的设置来解决这些问题就叫作CSS Hack。 比如：kwstu{width:300px;_width:200px;}，一般浏览器会先给元素使用width:300px;的样式，紧接着后面还有个_width:200px;由于下划线_width只有IE6可以识别，所以此样式在IE6中实际设置对象的宽度为200px，后面的把前面的给覆盖了，而其他浏览器不识别_width不会执行_width:200px;这句样式，所以在其他浏览器中设置对象的宽度就是300px; 各种css hack情况 1.大部分特殊字符IE浏览器支持，其他主流浏览器firefox，chrome，opera，safari不支持 (opera可识别除外)。 2.\\9 ：所有IE浏览器都支持 3._和- ：仅IE6支持 4.* ：IE6、E7支持 5.\\0 ：IE8、IE9支持，opera部分支持 6.\\9\\0 ：IE8部分支持、IE9支持 7.\\0\\9 ：IE8、IE9支持 兼容各大主流浏览器(最新版本)css hack汇总如下（最全的）：12345678910color:#000; /*w3c标准*/[;color:#f00;]; /*Webkit(chrome和safari)*/color:#666\\9; /*IE8*/*color:#999; /*IE7*/_color:#333; /*IE6*/&#125;:root .element&#123;color:#0f0\\9;&#125; /*IE9*/@media all and (-webkit-min-device-pixel-ratio:10000), not all and (-webkit-min-device-pixel-ratio:0) &#123; .element&#123;color:#336699;&#125;&#125; /*opera*/@-moz-document url-prefix()&#123; .element&#123;color:#f1f1f1;&#125;&#125; /*Firefox*/ 上面写的顺序是不能改变的【说明】：“:root”伪类IE系列只有IE9支持，其他主流浏览器均支持，利用这一点来区分IE8和IE9。另外考虑到opera部分支持，完全支持:root,所以不使用。","tags":[{"name":"css","slug":"css","permalink":"http://liumeilian.com.cn/tags/css/"}]},{"title":"flex布局","date":"2017-04-12T07:39:59.710Z","path":"2017/04/12/flex/","text":"flex布局也就是弹性布局由于觉得阮一峰老师的博客已经写得非常详细，而且通俗易懂，这里附上他的链接，以后方便复习 Flex 布局教程：语法篇Flex 布局教程：实例篇 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 使用flex布局应该注意些什么 1.Webkit内核的浏览器，必须加上-webkit前缀。 2.任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。 3.设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 容器的属性以下6个属性设置在容器上。 1.flex-direction 2.flex-wrap 3.flex-flow 4.justify-content 5.align-items 6.align-content flex-direction属性决定主轴的方向（即项目的排列方向）。.box { flex-direction: row | row-reverse | column | column-reverse;} flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。.box{ flex-wrap: nowrap | wrap | wrap-reverse;} flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap justify-content属性justify-content属性定义了项目在主轴上的对齐方式。.box { justify-content: flex-start | flex-end | center | space-between | space-around;} align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch;} baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} stretch（默认值）：轴线占满整个交叉轴。 以下6个属性设置在项目上。 1.order 2.flex-grow 3.flex-shrink 4.flex-basis 5.flex 6.align-self order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。","tags":[{"name":"css3","slug":"css3","permalink":"http://liumeilian.com.cn/tags/css3/"}]},{"title":"关于变量的作用域","date":"2017-04-11T13:50:58.577Z","path":"2017/04/11/funcaera/","text":"难以描述，直接上代码方便理解一些 1234function a()&#123; alert(s);//这里会报错 s is not defined &#125; a(); 12345var c=s=10;//这里定义了一个全局变量s，且初始化为10function a()&#123; alert(s);//10&#125;a(); 12345var s=10; function a(s)&#123; alert(s);//10 &#125; a(s); 1234567var s=10; function a(s)&#123; var s;//由于s与形参名相同，所以相当于重新定义一边s，其实这个s就是形参s //虽然上面那句话没有初始化s，但是由于他就是形参s，所以里面的值还是10 alert(s);//10 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; alert(s);//20 &#125; a(s); 123456var s=10; function a(s)&#123; var s=20; alert(s);//20 &#125; a(s); 12345678var s=10; function a(s)&#123; var s; alert(s);//10 s=20; &#125; a(s); alert(s);//10 123456function a()&#123; s=3; alert(s);//3 &#125; a(); alert(s);//3 12345var str=1;alert(str);//1str=\"adadwds\";alert(str);//adadwds，这里是不会报错的，//因为js的变量可以用来保存任何类型的值，虽然不推荐但是却没有错 解析好吧，感觉脑子快炸掉了 下面分析一下not define undefined null NaN一.not define1alert(a);//报错 a is not define not define说明变量没有被定义 undefined12var a;alert(a);//undefined undefined表示a已经被定义了，但是由于没有被初始化，所以系统给他赋值为undefined null12var a=document.getElementById(\"main\"); alert(a);//null null是Null类型的值，null值表示一个空对象的指针，一般用在一个变量想要保存一个对象但是还没有保存上面这个例子的意思就是a本来想保存一个对象，但是获取不到main所以他还是原来的值null NaN是Number类型的一个值意思是非数值NaN有两个特点，第一，任何涉及NaN的操作都会返回NaN，第二，NaN与任何值都不想等包括NaN本身isNaN函数接受一个参数，这个参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN（）在接受一个参数之后，会先尝试把这个参数转化成数值。某些不是数值的值会直接转化为数值，比如“10”或Boolean值。而任何不能被转化为数值的值都会导致这个函数返回true 12345alert(isNaN(NaN));//truealert(isNaN(10));//falsealert(isNaN(\"10\"));//falsealert(isNaN(\"blue\"));//truealert(isNaN(true));//false 这里再讨论一个题外话当没给setInterval设置时间函数的执行顺序是什么 12345setInterval(function()&#123; console.log(1); &#125;); console.log(2); 这个程序会先打印2，再打印1","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"原生jquery是如何写出来的","date":"2017-04-11T08:13:39.563Z","path":"2017/04/11/originjquery/","text":"原生jQ的写法$(function(){}) $(‘#div1’) $(‘.box’) $(‘p’)的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function $(vArg)&#123; return new Vquery(vArg);&#125;function Vquery(vArg)&#123; this.elements = []; //选择元素的这样一个集合 //vArg : function switch(typeof vArg)&#123; case 'function': //window.onload = vArg; bindEvent(window,'load',vArg); break; case 'string': switch( vArg.charAt(0) )&#123; case '#': //id this.elements.push(document.getElementById(vArg.substring(1))); break; case '.': //class this.elements = getByClass(document,vArg.substring(1)); break; default: //tag this.elements = toArray(document.getElementsByTagName(vArg)); break; &#125; break; case 'object': if( vArg.constructor == Array )&#123; this.elements = vArg; &#125; else&#123; this.elements.push( vArg ); &#125; break; &#125; &#125;function bindEvent(obj,events,fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(events,function(ev)&#123; //fn() -&gt; false //fn() -&gt; undefined if( fn() == false )&#123; ev.preventDefault(); ev.cancelBubble = true; &#125; &#125;,false); &#125; else&#123; obj.attachEvent('on'+events,function()&#123; if( fn() == false )&#123; window.event.cancelBubble = true; return false; &#125; &#125;); &#125;&#125;//下面是一些辅助函数function getByClass(oParent,sClass)&#123; var arr = []; var elems = oParent.getElementsByTagName('*'); for(var i=0;i&lt;elems.length;i++)&#123; if( elems[i].className == sClass )&#123; arr.push( elems[i] ); &#125; &#125; return arr; &#125;function toArray(elems)&#123; var arr = []; for(var i=0;i&lt;elems.length;i++)&#123; arr.push(elems[i]); &#125; return arr;&#125;function getStyle(obj,attr)&#123; if(obj.currentStyle)&#123; return obj.currentStyle[attr]; &#125; else&#123; return getComputedStyle(obj,false)[attr]; &#125;&#125; $().css() $().html()的实现12345678910111213141516171819202122Vquery.prototype.html = function(str)&#123; if(str)&#123; //设置 for(var i=0;i&lt;this.elements.length;i++)&#123; this.elements[i].innerHTML = str; &#125; &#125; else&#123; //获取 return this.elements[0].innerHTML; &#125; return this;&#125;;Vquery.prototype.click = function(fn)&#123; /*for(var i=0;i&lt;this.elements.length;i++)&#123; bindEvent(this.elements[i],'click',fn); &#125;*/ this.on('click',fn); return this; &#125;;","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"jq","slug":"jq","permalink":"http://liumeilian.com.cn/tags/jq/"}]},{"title":"笔试中hotelnum","date":"2017-04-11T02:19:59.970Z","path":"2017/04/11/hotelnum/","text":"问题你要出去旅游，有N元的预算住酒店，有M家酒店供你挑选，这些酒店都有价格X。 需要你正好花完这N元住酒店（不能多，也不能少）最少能住几晚？返回最少住的天数，没有匹配的返回-1 比如你有1000元，所有酒店都是大于1000的，则返回-1 比如你有1000元，有1家1000元的，有1家300，有1家700。则最少能住1晚，最多住2晚（300+700）。返回1 比如你有1000元，有1家387元，有1家2元，有一家611，则返回3（3家各住1天） 比如你有1000元，有1家1元的，有一家2元的，有一家1001元的，则返回500（1元的1000天，2元的500天）输入n个int，最后一个int为你拥有的钱，[0, n-2]为酒店的价格 样例输入 1001 1002 1003 2001 1000 输出返回最少住的天数，没有匹配的返回-1 样例输出-1 思想 1.先把各个酒店的价格排序， 2.用剩下的钱除以剩下的酒店中价格最高的，这里如果商大于0，day要不断加加 3.用剩下的钱对剩下的酒店中价格最高的取余，如果余数为0，跳出循环 4.如果循环正常结束说明钱没有刚好花完，返回-1。 代码如下123456789101112131415161718192021222324252627282930313233343536var str1='1001 1002 1003 2001 1000'; var str2='300 700 1000 1000'; var str3='387 3 610 1000'; function hotelday(str)&#123; var arr=str.split(' '); for(var i=0;i&lt;arr.length;i++)&#123; arr[i]=parseInt(arr[i]); &#125; var money=arr[arr.length-1]; var hotel=[]; for(i=0;i&lt;arr.length-1;i++)&#123; hotel.push(arr[i]); &#125; hotel=hotel.sort(function compare(a,b)&#123; return a-b;//这里的compare是规定排序的方式 &#125;); var len=hotel.length; var day=0; for(i=len-1;i&gt;=0;i--)&#123; var shang=Math.floor(money/hotel[i]);//floor为向下取整,ceil为向上取整，round为四舍五入 var yushu=money%hotel[i]; if(shang!=0)&#123; day+=shang;//day记录天数 &#125; if(yushu==0)&#123; break;//余数为0就没有跳出循环 &#125; money=yushu; &#125; if(i==-1)&#123; return -1;//循环正常结束 &#125; return day; &#125; alert(hotelday(str3)); 区分sort和reverse 这两个函数功能不是相反的关系，这两个函数一点关系都没有 sort是把数组里的元素排列顺序 reverse是颠倒数组的元素的顺序,就是arr[0]和arr[length-1]交换,arr[1]和arr[length-2]交换 sort一盒带参数，reverse没有参数 sort 当sort没有参数时，数组是按照ASCII排列的，此时它把数组里的元素都看成是字符串，字符串排序首字母（a-z）或（1-9）这样的顺序 如果要对数组排序的话sort就一定要有参数 数字小到大compare(a,b){return a-b;} 数字大到小compare(a,b){return b-a;} 123456789101112131415 var arr=[12,23,53,13,15,5]; alert(arr.sort());//12 13 15 23 5 53 var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return a-b;&#125;alert(arr.sort(compare));//5 12 13 15 23 53var arr=[12,23,53,13,15,5];function compare(a,b)&#123; return b-a;&#125;alert(arr.sort(compare));//53 23 15 13 12 5 reverse12var arr=[12,23,53,13,15,5];alert(arr.reverse());//5 15 14 53 23 12","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"函数的定义 函数声明 函数表达式 立即执行函数","date":"2017-04-08T12:28:16.653Z","path":"2017/04/08/function/","text":"函数的定义 1.函数通常是使用函数声明语法定义的，如下 123function sum(num1,num2)&#123; return num1+num2;&#125; 2.也可以用函数表达式定义,如下 123var sum=function(num1,num2)&#123; return num1+num2;&#125; 3.还可以用Function构造函数定义，如下 1var sum=new Function(\"num1\",\"num2\",\"return num1+num2\");//不推荐 函数声明与函数表达式的定义 函数声明：function fnName () {…};使用function关键字声明一个函数，再指定一个函数名，叫函数声明。 函数表达式 var fnName = function () {…};使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。 匿名函数：function () {}; 使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。 #函数声明与函数表达式的区别 一、JavaScript引擎在解析javascript代码时会‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明，而函数表达式必须等到Javascirtp引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式 二、函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用 12345678910111213141516171819202122fnName();function fnName()&#123; ...&#125;//正常，因为‘提升’了函数声明，函数调用可在函数声明之前fnName();var fnName=function()&#123; ...&#125;//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后var fnName=function()&#123; alert('Hello World');&#125;();//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数function fnName()&#123; alert('Hello World');&#125;();//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用function()&#123; console.log('Hello World'); &#125;();//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名 在理解了一些函数基本概念后，回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法 1234567891011121314151617181920212223(function(a)&#123; console.log(a); //firebug输出123,使用（）运算符&#125;)(123);(function(a)&#123; console.log(a); //firebug输出1234，使用（）运算符&#125;(1234));!function(a)&#123; console.log(a); //firebug输出12345,使用！运算符&#125;(12345);+function(a)&#123; console.log(a); //firebug输出123456,使用+运算符&#125;(123456);-function(a)&#123; console.log(a); //firebug输出1234567,使用-运算符&#125;(1234567);var fn=function(a)&#123; console.log(a); //firebug输出12345678，使用=运算符&#125;(12345678) 可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"找出字符串中出现最多的字符和次数","date":"2017-04-08T11:53:17.281Z","path":"2017/04/08/maxstr/","text":"问题12var str = 'assssjdssskssalsssdkjsssdss';//找出str中出现最多的字符s 解答12345678910111213141516171819202122232425var str = 'assssjdssskssalsssdkjsssdss';var arr = str.split('');str = arr.sort().join('');alert(str);//aadddjjkklsssssssssssssssssvar value = '';var index = 0;var re = /(\\w)\\1+/g;str.replace(re,function($0,$1)&#123; //alert($0); if(index&lt;$0.length)&#123; index = $0.length; value = $1; &#125; &#125;);alert('最多的字符:'+value+',重复的次数:'+index);","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]},{"title":"正则表达式","date":"2017-04-08T08:15:21.110Z","path":"2017/04/08/reg/","text":"正则表达式常用方法test用途：字符串判断 -返回真假 -正则.test(字符串) -例子：是否有不知数字的字符 123var str=\"akjkcs123232\";var re=/\\D/;alert(re.test(str));//true \\s : 空格\\S : 非空格\\d : 数字\\D : 非数字\\w : 字符 ( 字母 ，数字，下划线_ )\\W : 非字符*/ search用途：字符串搜索 -返回出现的位置 -字符串.search(正则) 12345678910111213141516//search : 正则去匹配字符串 , 如果匹配成功，就返回匹配成功的位置，如果匹配失败就返回 -1//search的写法 : 字符串.search(正则)//正则中的默认 : 是区分大小写的 //如果不区分大小写的话，在正则的最后加标识 i var str = 'abcdef';var re = /B/i;//var re = new RegExp('B','i');alert( str.search(re) );//1 match用途：获取匹配项目 -返回数组 -量词+ -全局匹配g -例子：找出所有数字 123456789101112131415//match : 正则去匹配字符串，如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回null//match的写法 : 字符串.match(正则)//正则默认：正则匹配成功就会结束，不会继续匹配 //如果想全部查找，就要加标识 g(全局匹配)//量词 : 匹配不确定的位置//+ : 至少出现一次var str = 'haj123sdk54hask33dkhalsd879';var re = /\\d+/g;alert( str.match(re) ); //[123,54,33,879] replace用途：替换所有匹配 -返回替换后的字符串 -字符串.replace(正则) 12345678910//replace : 正则去匹配字符串，匹配成功的字符去替换成新的字符串//replace的写法 : 字符串.replace(正则,新的字符串)var str = 'aaa';var re = /a+/g;str = str.replace(re,'b');alert(str);//b 下面给出一个敏感词过滤的例子 1234567891011121314151617181920212223242526272829303132333435//菲称仁爱礁附近17艘中国船均在菲军监视之下//| : 或的意思//replace : 第二个参数：可以是字符串，也可以是一个回调函数window.onload = function()&#123; var aT = document.getElementsByTagName('textarea'); var oInput = document.getElementById('input1'); var re = /菲称|中国船|监视之下/g; oInput.onclick = function()&#123; //aT[1].value = aT[0].value.replace(re,'*'); aT[1].value = aT[0].value.replace(re,function(str)&#123; //函数的第一个参数：就是匹配成功的字符 //alert( str ); var result = ''; for(var i=0;i&lt;str.length;i++)&#123; result += '*'; &#125; return result; &#125;); &#125;; &#125;; 子项问题把正则的整体叫做（母亲）然后把左边第一个小括号里面的正则，叫做这个第一个子项(母亲的第一个孩子)第二个小括号就是第二个孩子 1234567891011121314151617var str = '2013-6-7';var re = /(\\d+)(-)/g;str = str.replace(re,function($0,$1,$2)&#123; //第一个参数：$0（母亲）,第二个参数 : $1(第一个孩子) //,第二个参数 : $1(第二个孩子) //alert( $2 ); //return $1 + '.'; return $0.substring(0,$0.length-1) + '.'; &#125;);alert( str ); //2013.6.7 12345var str = 'abc';var re = /(a)(b)(c)/;alert( str.match(re) ); //[abc,a,b,c](当match不加g的时候才可以获取到子项的集合) 字符类字符类 : 一组相似的元素 [] 中括号的整体代表一个字符 12345var str = 'abdc';var re = /a[bde]c/;alert( re.test(str) );//false 排除排除 : ^ 如果^写在[]里面的话，就代表排除的意思 1234567891011var str = 'abc';var re = /a[^bde]c/;alert( re.test(str) );var str = 'abc';var re = /a[a-z0-9A-Z]c/;alert( re.test(str) );//true . : 任意字符 , . : 真正的点12345var str = 'a.c';var re = /a\\.c/;alert(re.test(str));//true \\b : 独立的部分 （ 起始，结束，空格 ）, \\B : 非独立的部分12345var str = 'onetwo';var re = /o\\b/;alert( re.test(str) );//true 重复子项\\1 : 重复的第一个子项\\2 : 重复的第二个子项 12345var str = 'abca';var re = /(a)(b)(c)\\2/;alert( re.test(str) );//false 量词 {4,7} : 最少出现4次，最多出现7次 {4,} : 最少出现4次 {4} : 正好出现4次 : {1,} //\\d{1,} ? : {0,1} : 出现0次或者1次 : {0,} : 至少出现0次 ^开始 $结束12//^ : 正则的最开始位置，就代笔起始的意思//$ : 正则的最后位置 , 就代笔结束的意思 用RegExp构造函数来创建正则表达式123var str=\"catastrophe\";var re=new RegExp(\"cat\",\"g\");re.test(str);//true 注意字符\\在字符串中通常被转义为\\,而在正则表达式中就会被转义为\\\\ 字面量模式和等价的字符串的比较如下 /[bc]at/ == “\\[bc\\]at” /.at/ ==”\\.at” /\\d.\\d{1,2}/ == “\\d.\\d{1,3}” /\\w\\hello\\123/ == “\\w\\\\hello\\\\123” 总之字面量的一个\\ 会变成两个\\ 1234567var str='R23C45';var re1=/^R\\d+C\\d+$/;var re2=new RegExp(\"^R\\d+C\\d+$\");var re3=new RegExp(\"^R\\\\d+C\\\\d+$\");alert(str.match(re1));//[R23C45]alert(str.match(re2));//nullalert(str.match(re3));//[R23C45]","tags":[{"name":"js","slug":"js","permalink":"http://liumeilian.com.cn/tags/js/"}]},{"title":"用对象下的属性替换字符串中的字符","date":"2017-04-08T02:35:32.848Z","path":"2017/04/08/replacestring/","text":"问题123456789var str='my name is $&#123;name.name&#125;,jian xie $&#123;b&#125;';var json=&#123; \"name\":&#123;\"name\":\"hzhuang\",\"minname\":\"zhuangzhuang\"&#125;, \"b\":\"hz\", \"n\":1, \"arr\":[1,2,3]&#125;;var result=str.render(json);console.log(result);//my name is hzhuang,jian xie hz 如上面的代码希望给str绑定一个函数render，是的result的结果是my name is hzhuang,jian xie hz 思路 用replace函数把str里的${name.name}，${b}替换成json里的数据 用json的数据替换str里的${name.name}，${b} 方法一123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(typeof obj[keys[i]]== 'object')&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析上述代码中（typeof obj[keys[i]]== ‘object’）的判断不够全面，因为typeof arr，其中arr为数组的话，弹出的也是object 方法二123456789101112131415161718String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; if(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\")&#123; var item=obj[keys[i]]; for(var j=0;j&lt;Object.keys(item);j++)&#123; str=str.replace(\"$&#123;\"+keys[i]+\".\"+object.keys(item)[j]+\"&#125;\",\"\"+item[object.keys(item)[j]]); &#125; &#125;else&#123; str=str.replace(\"$&#123;\"+keys[i]+\"&#125;\",\"\"+obj[keys[i]]); &#125; &#125; return str;&#125; 解析Object.prototype.toString.call()是判断类型的一种方法,而且是能区分Array的方法 123456789101112String.prototype.render=function(json)&#123;//给系统对象绑定函数要绑定在原型上 var str=String(this);//String是把一个对象的值转化成字符串 var keys=Object.keys(json);//Object.keys()函数返回一个数组，即对象的可枚举属性和方法的名称。 //若要返回可枚举的和不可枚举的属性和方法的名称， //可使用 Object.getOwnPropertyNames 函数 (JavaScript) for(var i=0,i&lt;keys.length;i++)&#123; alert(Object.prototype.toString.call(obj[keys[i]]) == \"[object Object]\"); //[object object],[object String],[object number],[object Array] &#125; return str;&#125; 方法三12345678910111213141516171819String.prototype.render = function (obj) &#123; var _this = this; for (var p in obj) &#123; if (obj.hasOwnProperty(p) &amp;&amp; !(p instanceof Object)) &#123; var s = '$&#123;' + p + '&#125;'; str = _this.replace(s, obj[p]); _this = str; &#125; if(obj[p] instanceof Object)&#123; for(var m in obj[p]) &#123; var x = '$&#123;' + p + '.' + m + '&#125;'; //console.log(obj[p][m]); str = _this.replace(x, obj[p][m]); _this = str; &#125; &#125; &#125; return str;&#125; ##解析 instanceof是区分的最细致的数据类型的函数 使用 instanceof 就是判断一个实例是否属于某种类型 123456789101112131415161718var oStringObject = new String(\"hello world\"); console.log(oStringObject instanceof String); // 输出 \"true\" // 判断 foo 是否是 Foo 类的实例 function Foo()&#123;&#125; var foo = new Foo(); console.log(foo instanceof Foo)//true // 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例 function Aoo()&#123;&#125; function Foo()&#123;&#125; Foo.prototype = new Aoo();//JavaScript 原型继承 var foo = new Foo(); console.log(foo instanceof Foo)//true console.log(foo instanceof Aoo)//true typeof和instanceof的区别typeof和instanceof都可以用来判断变量，它们的用法有很大区别：typeof会返回一个变量的基本类型，只有以下几种：number,boolean,string,object,undefined,function；12345678910alert(typeof(1));//numberalert(typeof(\"abc\"));//stringalert(typeof(true));//booleanalert(typeof(m));//undefinedvar str=\"abc\";alert(typeof str);//stringvar arr=[];alert(typeof arr);//objectvar str1=new String(\"bjk\");alert(typeof str1);//object 可见区分不出str1和arr 如果我们想要判断一个变量是否存在，可以使用typeof：(不能使用if(a) 若a未声明，则报错) 123if(typeof a != 'undefined')&#123; //变量存在&#125; 需要注意的是，instanceof只能用来判断对象和函数，不能用来判断字符串和数字等，如： 123456var b = '123';alert(b instanceof String); //falsealert(typeof b); //stringvar c = new String(\"123\");alert(c instanceof String); //truealert(typeof c); //object 判断数组的几种方法 1、constructor属性 这个属性在我们使用js系统或者自己创建的对象的时候，会默认的加上，例如： arr = [1,2,3];link1234arr.prototype.constructor = Array; //这一句是系统默认加上的所以我们就可以这样来判断：var arr = [1,2,3,1]; alert(arr.constructor === Array); // true 2、instanceofinstanceof是检测对象的原型链是否指向构造函数的prototype对象的，所以我们也可以用它来判断： 12var arr = [1,2,3]; alert(arr instanceof Array); // true 最后，为了给大家一个结果，现写出一个终极解决方案：判断数组终极解决方案arr = [1,2,3]; 12345678function isArrayFn(obj)&#123; //封装一个函数if (typeof Array.isArray === &quot;function&quot;) &#123; return Array.isArray(obj); //浏览器支持则使用isArray()方法&#125;else&#123; //否则使用toString方法return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;; &#125; &#125; alert(isArrayFn(arr));// true","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"字符串的操作","slug":"字符串的操作","permalink":"http://liumeilian.com.cn/tags/字符串的操作/"}]},{"title":"右边固定宽左边自适应的布局和左边固定宽度右边自适应的布局","date":"2017-04-07T13:50:25.437Z","path":"2017/04/07/a/","text":"右边固定宽左边自适应的布局这是一个简单的布局实现。 123456789101112131415161718192021222324252627&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; margin-right: 200px; background-color:#ff0; height:500px; &#125; .right &#123; background-color:#f00; height:500px; width:200px; position: absolute; right: 0; top: 0; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 左边固定宽友边自适应的布局12345678910111213141516171819202122232425&lt;style type=\"text/css\"&gt; *&#123;margin:0;padding:0;&#125; body #lay&#123; width:800px; background-color:#ccc; position: relative; &#125; .left &#123; width: 200px; background-color:#ff0; height:500px; float: left; &#125; .right &#123; background-color:#f00; height:500px; margin-left: 200px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id=\"lay\"&gt; &lt;main class=\"left\"&gt;left&lt;/main&gt; &lt;aside class=\"right\"&gt;right&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt; 注意当两个div元素同级时，就像main和aside，main来float与aside来float是不一样的。main来float那么这两个元素并列，如果aside来float那么这两个元素不在同一行，如果aside来float那么aside就会跑到main的下方。","tags":[{"name":"布局","slug":"布局","permalink":"http://liumeilian.com.cn/tags/布局/"}]},{"title":"刘美莲博客测试","date":"2017-04-04T13:40:13.757Z","path":"2017/04/04/text/","text":"这是一个目录二级六级第二部分 hzhuang liumeilian hangzhou xian 第二部分 表格 标题一 标题二 标题三 1 2 3 4 5 6 第三部分 代码高亮1234567function test()&#123; if(xxx)&#123; &#125;else&#123; //... &#125;&#125; 第四部分linkName 第五部分 图","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"},{"name":"测试","slug":"测试","permalink":"http://liumeilian.com.cn/tags/测试/"}]},{"title":"查找两个字符串中最长的公共子串","date":"2017-03-25T12:48:33.000Z","path":"2017/03/25/maxLength/","text":"问题：str1=“aaa3333”；str2=“vscscsaaa33”;求str1和str2中最长的公共子串aaa33 思想：在长的字符串str2里面找最长的str1的子串 分析步骤： 1现在str2里面找 aaa3333，str1的长度是7，下标是0-6，先在str2中找str1的0-6的字符串aaa3333，找 的长度是7 2找不到aaa3333，再找str1中0-5的字符串aaa333，找不到，再找1-6的字符串aa3333，找不到，找的 长度是6。 3再找0-4的字符串aaa33，找到了就结束查找。 js代码实现：1234567891011121314151617181920 function LongestCommonStr(s1,s2)&#123; var str=\"\"; var L1=s1.length; var L2=s2.length; if(L1&gt;L2)&#123; L1=L2; var s3=s2; s2=s1; s1=s3; &#125; for(var j=L1;j&gt;0;j--)&#123; for(var i=0;i&lt;L1-j;i++)&#123; str=s1.substr(i,j); if(s2.indexOf(str)&gt;=0)&#123; return str; &#125; &#125; &#125; return \"\";&#125; 代码说明： 1外层的j循环代表先找7个，再找6个，再找5个str1中的子串 2内层循环代表先找0-4，再找1-5，再找2-6中的0 1 2这个顺序 2indexOf（searchvalue，fromindex）这个函数返回searchvalue出现的首位置，fromindex表示开始查到的位置，默认为0；","tags":[{"name":"算法","slug":"算法","permalink":"http://liumeilian.com.cn/tags/算法/"}]}]